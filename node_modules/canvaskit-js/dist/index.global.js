"use strict";
(() => {
  // src/HostObject.ts
  var generateId = () => Date.now().toString(36) + Math.random().toString(36).substring(2, 9);
  var HostObject = class {
    constructor(__type__) {
      this.__type__ = __type__;
    }
    // TODO: remove when upgrading canvaskit
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    clone() {
      throw new Error("Method not implemented.");
    }
    delete() {
    }
    deleteLater() {
    }
    isAliasOf(_other) {
      throw new Error("Method not implemented.");
    }
    isDeleted() {
      return false;
    }
  };
  var IndexedHostObject = class extends HostObject {
    id;
    constructor(type, prefix) {
      super(type);
      this.id = `${prefix}-${generateId()}`;
    }
  };

  // src/Core/GrDirectContext.ts
  var GrDirectContextJS = class extends HostObject {
    constructor(ctx) {
      super("GrDirectContext");
      this.ctx = ctx;
    }
    limit = 5 * 3840 * 2160 * 4;
    cache = /* @__PURE__ */ new Map();
    getResourceCacheLimitBytes() {
      return this.limit;
    }
    getResourceCacheUsageBytes() {
      return Array.from(this.cache.values()).reduce(
        (acc, bitmap) => acc + bitmap.width * bitmap.height * 4,
        0
      );
    }
    releaseResourcesAndAbandonContext() {
      this.cache.clear();
    }
    setResourceCacheLimitBytes(limit) {
      this.limit = limit;
    }
    get(id) {
      return this.cache.get(id);
    }
    set(id, bitmap) {
      this.cache.set(id, bitmap);
    }
  };

  // src/Core/Platform.ts
  var createTexture = (width, height, options) => {
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d", options);
    if (!ctx) {
      throw new Error("Could not create 2d context");
    }
    return ctx;
  };
  var createOffscreenTexture = (width, height, options) => {
    const canvas = new OffscreenCanvas(width, height);
    const ctx = canvas.getContext("2d", options);
    if (!ctx) {
      throw new Error("Could not create 2d context");
    }
    return ctx;
  };
  var resolveContext = (canvas, options) => {
    let resolved;
    if (typeof canvas === "string") {
      const el = document.getElementById(canvas);
      if (!el) {
        return null;
      }
      resolved = el;
    } else {
      resolved = canvas;
    }
    return resolved.getContext("2d", options);
  };

  // src/c2d/Constants.ts
  var IndexedHostObject2 = class {
    id;
    constructor(prefix) {
      this.id = `${prefix}-${generateId2()}`;
    }
  };
  var generateId2 = () => Date.now().toString(36) + Math.random().toString(36).substring(2, 9);

  // src/c2d/Path/Vector.ts
  var projectPoint = (matrix, point) => {
    const p = new DOMPoint(point.x, point.y, 0, 1).matrixTransform(matrix);
    return new DOMPoint(p.x / p.w, p.y / p.w);
  };
  var dist = (p1, p2) => Math.hypot(p2.x - p1.x, p2.y - p1.y);
  var vec = (x, y) => new DOMPoint(x, y);
  var plus = (p1, p2) => new DOMPoint(p1.x + p2.x, p1.y + p2.y);
  var minus = (p1, p2) => new DOMPoint(p1.x - p2.x, p1.y - p2.y);
  var multiply = (p1, p2) => new DOMPoint(p1.x * p2.x, p1.y * p2.y);
  var multiplyScalar = (p, scale) => new DOMPoint(p.x * scale, p.y * scale);
  var dot = (p1, p2) => p1.x * p2.x + p1.y * p2.y;
  var cross = (p1, p2) => p1.x * p2.y - p1.y * p2.x;
  var magnitude = (p) => Math.sqrt(p.x * p.x + p.y * p.y);
  var normalize = (p) => {
    const m = magnitude(p);
    return new DOMPoint(p.x / m, p.y / m);
  };

  // src/c2d/Path/PathComponents/Polyline.ts
  var Polyline = class {
    constructor(items) {
      this.items = items;
      this.cumulativeLengths = this.calculateCumulativeLengths();
    }
    cumulativeLengths;
    length() {
      return this.cumulativeLengths[this.cumulativeLengths.length - 1];
    }
    tAtLength(length2) {
      if (length2 === 0) {
        return 0;
      } else if (length2 === this.length()) {
        return 1;
      }
      const index = this.findIndex(length2);
      if (index === -1) {
        throw new Error(`Index not found for length ${length2}`);
      }
      const prev = this.items[index - 1].t;
      const next = this.items[index].t;
      const l1 = this.cumulativeLengths[index - 1];
      const l2 = this.cumulativeLengths[index];
      return lerp((length2 - l1) / (l2 - l1), prev, next);
    }
    findIndex(length2) {
      if (length2 < 0 || length2 > this.length()) {
        throw new Error(`Length out of bounds ${length2} - ${this.length()}`);
      } else if (length2 === this.length()) {
        return this.cumulativeLengths.length - 1;
      }
      const index = this.cumulativeLengths.findIndex((l) => l > length2);
      return index;
    }
    calculateCumulativeLengths() {
      const cumulativeLengths = [0];
      for (let i = 1; i < this.items.length; i++) {
        const previousItem = this.items[i - 1];
        const currentItem = this.items[i];
        const segmentLength = dist(currentItem.point, previousItem.point);
        cumulativeLengths[i] = cumulativeLengths[i - 1] + segmentLength;
      }
      return cumulativeLengths;
    }
    computeTightBounds() {
      if (this.items.length === 0) {
        throw new Error("The polyline has no points to determine bounds.");
      }
      let minX = this.items[0].point.x;
      let minY = this.items[0].point.y;
      let maxX = this.items[0].point.x;
      let maxY = this.items[0].point.y;
      for (const item of this.items) {
        const { x, y } = item.point;
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
      }
      return Float32Array.of(minX, minY, maxX, maxY);
    }
  };
  var lerp = (t, a, b) => (1 - t) * a + t * b;
  var linearSolve = (t, p0, p1) => new DOMPoint(lerp(t, p0.x, p1.x), lerp(t, p0.y, p1.y));
  var linearSolveDerivative = (p1, p2) => {
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const magnitude2 = Math.hypot(dx, dy);
    return new DOMPoint(dx / magnitude2, dy / magnitude2);
  };

  // src/c2d/Path/PathComponents/LinearPathComponent.ts
  var LinearPathComponent = class _LinearPathComponent {
    constructor(p1, p2) {
      this.p1 = p1;
      this.p2 = p2;
    }
    type = 0 /* Linear */;
    segment(start, stop) {
      return new _LinearPathComponent(
        this.solve(this.tAtLength(start)),
        this.solve(this.tAtLength(stop))
      );
    }
    computeTightBounds() {
      const minX = Math.min(this.p1.x, this.p2.x);
      const minY = Math.min(this.p1.y, this.p2.y);
      const maxX = Math.max(this.p1.x, this.p2.x);
      const maxY = Math.max(this.p1.y, this.p2.y);
      return Float32Array.of(minX, minY, maxX, maxY);
    }
    solve(t) {
      return linearSolve(t, this.p1, this.p2);
    }
    solveDerivative() {
      return linearSolveDerivative(this.p1, this.p2);
    }
    tAtLength(length2) {
      return length2 / this.length();
    }
    toCmd() {
      return [1 /* Line */, this.p2.x, this.p2.y];
    }
    toSVGString() {
      return `L${this.p2.x} ${this.p2.y}`;
    }
    length() {
      return dist(this.p1, this.p2);
    }
  };

  // src/c2d/Path/PathComponents/Flattenable.ts
  var Flatennable = class {
    _polyline = null;
    get polyline() {
      if (this._polyline === null) {
        this._polyline = this.createPolyline();
      }
      return this._polyline;
    }
    tAtLength(length2) {
      return this.polyline.tAtLength(length2);
    }
    length() {
      return this.polyline.length();
    }
  };

  // src/c2d/Path/PathComponents/QuadraticPathComponent.ts
  var defaultCurveTolerance = 0.1;
  var QuadraticPathComponent = class _QuadraticPathComponent extends Flatennable {
    constructor(p1, cp, p2) {
      super();
      this.p1 = p1;
      this.cp = cp;
      this.p2 = p2;
    }
    type = 1 /* Quadratic */;
    createPolyline() {
      return new Polyline(this.fillPolyline());
    }
    fillPolyline(scaleFactor = 1) {
      const points = [{ t: 0, point: this.p1 }];
      const tolerance = defaultCurveTolerance / scaleFactor;
      const sqrtTolerance = Math.sqrt(tolerance);
      const d01 = minus(this.cp, this.p1);
      const d12 = minus(this.p2, this.cp);
      const dd = minus(d01, d12);
      const crossV = cross(minus(this.p2, this.p1), dd);
      const x0 = dot(d01, dd) * 1 / crossV;
      const x2 = dot(d12, dd) * 1 / crossV;
      const scale = Math.abs(crossV / (Math.hypot(dd.x, dd.y) * (x2 - x0)));
      const a0 = approximateParabolaIntegral(x0);
      const a2 = approximateParabolaIntegral(x2);
      let val = 0;
      if (Number.isFinite(scale)) {
        const da = Math.abs(a2 - a0);
        const sqrtScale = Math.sqrt(scale);
        if (x0 < 0 && x2 < 0 || x0 >= 0 && x2 >= 0) {
          val = da * sqrtScale;
        } else {
          const xmin = sqrtTolerance / sqrtScale;
          val = sqrtTolerance * da / approximateParabolaIntegral(xmin);
        }
      }
      const u0 = approximateParabolaIntegral(a0);
      const u2 = approximateParabolaIntegral(a2);
      const uScale = 1 / (u2 - u0);
      const lineCount = Math.max(1, Math.ceil(0.5 * val / sqrtTolerance));
      const step = 1 / lineCount;
      for (let i = 1; i < lineCount; i += 1) {
        const u = i * step;
        const a = a0 + (a2 - a0) * u;
        const t = (approximateParabolaIntegral(a) - u0) * uScale;
        points.push({ t, point: this.solve(t) });
      }
      points.push({ t: 1, point: this.p2 });
      return points;
    }
    chop(t, side) {
      const { p1: p0, cp: p1, p2 } = this;
      const p01 = linearSolve(t, p0, p1);
      const p12 = linearSolve(t, p1, p2);
      if (side === "left") {
        return new _QuadraticPathComponent(p0, p01, linearSolve(t, p01, p12));
      } else {
        return new _QuadraticPathComponent(linearSolve(t, p01, p12), p12, p2);
      }
    }
    segment(l0, l1) {
      const t0 = this.tAtLength(l1);
      const q1 = this.chop(t0, "left");
      const t1 = q1.tAtLength(l0);
      return q1.chop(t1, "right");
    }
    toSVGString() {
      return `Q${this.cp.x} ${this.cp.y} ${this.p2.x} ${this.p2.y}`;
    }
    toCmd() {
      return [2 /* Quad */, this.cp.x, this.cp.y, this.p2.x, this.p2.y];
    }
    solve(t) {
      return new DOMPoint(
        quadraticSolve(t, this.p1.x, this.cp.x, this.p2.x),
        quadraticSolve(t, this.p1.y, this.cp.y, this.p2.y)
      );
    }
    solveDerivative(t) {
      return normalize(
        new DOMPoint(
          quadraticSolveDerivative(t, this.p1.x, this.cp.x, this.p2.x),
          quadraticSolveDerivative(t, this.p1.y, this.cp.y, this.p2.y)
        )
      );
    }
    computeTightBounds() {
      return this.polyline.computeTightBounds();
    }
  };
  var approximateParabolaIntegral = (x) => {
    const d = 0.67;
    return x / (1 - d + Math.sqrt(Math.sqrt(Math.pow(d, 4) + 0.25 * x * x)));
  };
  var quadraticSolve = (t, p0, p1, p2) => (1 - t) * (1 - t) * p0 + //
  2 * (1 - t) * t * p1 + //
  t * t * p2;
  var quadraticSolveDerivative = (t, p0, p1, p2) => 2 * (1 - t) * (p1 - p0) + //
  2 * t * (p2 - p1);

  // src/c2d/Math.ts
  var clamp = (value, min, max) => {
    return Math.min(Math.max(value, min), max);
  };
  var saturate = (value) => clamp(value, 0, 1);
  var toRad = (deg) => deg * Math.PI / 180;
  var TAU = 2 * Math.PI;
  var PI_OVER_2 = Math.PI / 2;
  var ARC_APPROXIMATION_MAGIC = 0.551915024494;

  // src/c2d/Path/PathComponents/CubicPathComponent.ts
  var CubicPathComponent = class _CubicPathComponent extends Flatennable {
    constructor(p1, cp1, cp2, p2) {
      super();
      this.p1 = p1;
      this.cp1 = cp1;
      this.cp2 = cp2;
      this.p2 = p2;
    }
    type = 2 /* Cubic */;
    // alternative implementation https://gist.github.com/wcandillon/c6df05d80e036d19ad25456555912b62
    createPolyline() {
      const items = this.toQuadraticPathComponents(0.4).flatMap(
        (quad) => quad.fillPolyline()
      );
      const totalLength = items.reduce((acc, _, i) => {
        if (i === 0) {
          return 0;
        }
        return acc + dist(items[i - 1].point, items[i].point);
      }, 0);
      let offset = 0;
      for (let i = 0; i < items.length; i++) {
        if (i === 0) {
          items[0].t = 0;
          items[0].point = this.p1;
        } else if (i === items.length - 1) {
          items[i].t = 1;
          items[i].point = this.p2;
        } else {
          const prev = items[i - 1].point;
          const current = items[i].point;
          const nextOffset = saturate(offset + dist(prev, current) / totalLength);
          items[i].t = nextOffset;
          items[i].point = this.solve(items[i].t);
          offset = nextOffset;
        }
      }
      return new Polyline(items);
    }
    toQuadraticPathComponents(accuracy) {
      const quads = [];
      const maxHypot2 = 432 * accuracy * accuracy;
      const p1x2 = new DOMPoint(
        3 * this.cp1.x - this.p1.x,
        3 * this.cp1.y - this.p1.y
      );
      const p2x2 = new DOMPoint(
        3 * this.cp2.x - this.p2.x,
        3 * this.cp2.y - this.p2.y
      );
      const p = new DOMPoint(p2x2.x - p1x2.x, p2x2.y - p1x2.y);
      const err = p.x * p.x + p.y * p.y;
      const quadCount = Math.max(
        1,
        Math.ceil(Math.pow(err / maxHypot2, 1 / 6))
      );
      for (let i = 0; i < quadCount; i++) {
        const t0 = i / quadCount;
        const t1 = (i + 1) / quadCount;
        const seg = this.subsegment(t0, t1);
        const segP1x2 = new DOMPoint(
          3 * seg.cp1.x - seg.p1.x,
          3 * seg.cp1.y - seg.p1.y
        );
        const segP2x2 = new DOMPoint(
          3 * seg.cp2.x - seg.p2.x,
          3 * seg.cp2.y - seg.p2.y
        );
        const middle = new DOMPoint(
          (segP1x2.x + segP2x2.x) / 4,
          (segP1x2.y + segP2x2.y) / 4
        );
        quads.push(new QuadraticPathComponent(seg.p1, middle, seg.p2));
      }
      return quads;
    }
    chop(t, side) {
      const { p1: p0, cp1: p1, cp2: p2, p2: p3 } = this;
      const p01 = linearSolve(t, p0, p1);
      const p12 = linearSolve(t, p1, p2);
      const p23 = linearSolve(t, p2, p3);
      const p012 = linearSolve(t, p01, p12);
      const p123 = linearSolve(t, p12, p23);
      const p0123 = linearSolve(t, p012, p123);
      if (side === "left") {
        return new _CubicPathComponent(p0, p01, p012, p0123);
      } else {
        return new _CubicPathComponent(p0123, p123, p23, p3);
      }
    }
    segment(l0, l1) {
      const t0 = this.tAtLength(l1);
      const c1 = this.chop(t0, "left");
      const t1 = c1.tAtLength(l0);
      return c1.chop(t1, "right");
    }
    subsegment(t0, t1) {
      const p0 = this.solve(t0);
      const p3 = this.solve(t1);
      const d = this.lower();
      const scale = (t1 - t0) * (1 / 3);
      const p1 = plus(p0, multiplyScalar(d.solve(t0), scale));
      const p2 = minus(p3, multiplyScalar(d.solve(t1), scale));
      return new _CubicPathComponent(p0, p1, p2, p3);
    }
    lower() {
      return new QuadraticPathComponent(
        multiplyScalar(minus(this.cp1, this.p1), 3),
        multiplyScalar(minus(this.cp2, this.cp1), 3),
        multiplyScalar(minus(this.p2, this.cp2), 3)
      );
    }
    toSVGString() {
      return `C${this.cp1.x} ${this.cp1.y} ${this.cp2.x} ${this.cp2.y} ${this.p2.x} ${this.p2.y}`;
    }
    toCmd() {
      return [
        4 /* Cubic */,
        this.cp1.x,
        this.cp1.y,
        this.cp2.x,
        this.cp2.y,
        this.p2.x,
        this.p2.y
      ];
    }
    solve(t) {
      return new DOMPoint(
        cubicSolve(t, this.p1.x, this.cp1.x, this.cp2.x, this.p2.x),
        cubicSolve(t, this.p1.y, this.cp1.y, this.cp2.y, this.p2.y)
      );
    }
    solveDerivative(t) {
      return normalize(
        new DOMPoint(
          cubicSolveDerivative(t, this.p1.x, this.cp1.x, this.cp2.x, this.p2.x),
          cubicSolveDerivative(t, this.p1.y, this.cp1.y, this.cp2.y, this.p2.y)
        )
      );
    }
    computeTightBounds() {
      return this.polyline.computeTightBounds();
    }
  };
  var cubicSolve = (t, p0, p1, p2, p3) => (1 - t) * (1 - t) * (1 - t) * p0 + 3 * (1 - t) * (1 - t) * t * p1 + 3 * (1 - t) * t * t * p2 + t * t * t * p3;
  var cubicSolveDerivative = (t, p1, cp1, cp2, p2) => 3 * (1 - t) * (1 - t) * (cp1 - p1) + 6 * (1 - t) * t * (cp2 - cp1) + 3 * t * t * (p2 - cp2);

  // src/c2d/Path/PathComponents/Bounds.ts
  var computeTightBounds = (col) => {
    let [top, left, bottom, right] = col[0].computeTightBounds();
    for (const obj of col) {
      const [currTop, currLeft, currBottom, currRight] = obj.computeTightBounds();
      top = Math.min(top, currTop);
      left = Math.min(left, currLeft);
      bottom = Math.max(bottom, currBottom);
      right = Math.max(right, currRight);
    }
    return Float32Array.of(left, top, right, bottom);
  };

  // src/c2d/Path/Contour.ts
  var Contour = class _Contour {
    constructor(closed) {
      this.closed = closed;
    }
    components = [];
    computeTightBounds() {
      return computeTightBounds(this.components);
    }
    getPosTanAtLength(length2) {
      let offset = 0;
      for (const component of this.components) {
        const componentLength = component.length();
        const nextOffset = offset + componentLength;
        if (nextOffset >= length2) {
          const l0 = Math.max(0, length2 - offset);
          const t = component.tAtLength(l0);
          const pos = component.solve(t);
          const tan = component.solveDerivative(t);
          return [pos, tan];
        }
        offset = nextOffset;
      }
      throw new Error("length out of bounds");
    }
    getSegment(start, stop) {
      const trimmedContour = new _Contour(false);
      if (start >= stop) {
        return trimmedContour;
      }
      let offset = 0;
      this.components.forEach((component) => {
        const componentLength = component.length();
        const nextOffset = offset + componentLength;
        if (nextOffset <= start || offset >= stop) {
          offset = nextOffset;
          return;
        }
        const l0 = Math.max(0, start - offset);
        const l1 = Math.min(componentLength, stop - offset);
        const partialContour = component.segment(l0, l1);
        trimmedContour.components.push(partialContour);
        offset = nextOffset;
      });
      return trimmedContour;
    }
    enumerateComponents(linearApplier, quadApplier, cubicApplier) {
      this.components.forEach((comp, index) => {
        if (comp instanceof LinearPathComponent && linearApplier) {
          linearApplier(comp, index);
        } else if (comp instanceof QuadraticPathComponent && quadApplier) {
          quadApplier(comp, index);
        } else if (comp instanceof CubicPathComponent && cubicApplier) {
          cubicApplier(comp, index);
        }
      });
    }
    length() {
      return this.components.reduce((acc, c) => acc + c.length(), 0);
    }
    getLastComponent() {
      return this.components[this.components.length - 1];
    }
    toCmds() {
      if (this.components.length === 0) {
        return [];
      }
      const [comp] = this.components;
      const cmds = [0 /* Move */, comp.p1.x, comp.p1.y];
      const cmdToAdd = this.components.map((c) => c.toCmd());
      if (this.closed) {
        cmdToAdd[cmdToAdd.length - 1] = [5 /* Close */];
      }
      cmds.push(...cmdToAdd.flat());
      return cmds;
    }
    toSVGString() {
      if (this.components.length === 0) {
        return "";
      }
      const [comp] = this.components;
      const cmds = [`M${comp.p1.x} ${comp.p1.y}`];
      cmds.push(...this.components.map((c) => c.toSVGString()));
      if (this.closed) {
        cmds[cmds.length - 1] = "Z";
      }
      return cmds.join(" ");
    }
  };

  // src/c2d/Path/Path.ts
  var Path = class {
    contours = [];
    current = new DOMPoint(0, 0);
    subpathStart = null;
    get contour() {
      if (this.contours.length === 0) {
        this.addContour();
      }
      return this.contours[this.contours.length - 1];
    }
    enumerateComponents(linearApplier, quadApplier, cubicApplier, contourApplier) {
      this.contours.forEach((c, index) => {
        if (contourApplier) {
          contourApplier(c, index);
        }
        c.enumerateComponents(linearApplier, quadApplier, cubicApplier);
      });
    }
    addContour(isClosed = false) {
      this.contours.push(new Contour(isClosed));
    }
    closeContour() {
      this.contour.closed = true;
      return this;
    }
    moveTo(p) {
      this.current = p;
      this.subpathStart = this.current;
      this.addContour();
      return this;
    }
    lineTo(p) {
      this.contour.components.push(new LinearPathComponent(this.current, p));
      this.current = p;
      return this;
    }
    quadraticCurveTo(controlPoint, point) {
      this.contour.components.push(
        new QuadraticPathComponent(this.current, controlPoint, point)
      );
      this.current = point;
      return this;
    }
    bezierCurveTo(cp1, cp2, point) {
      this.contour.components.push(
        new CubicPathComponent(this.current, cp1, cp2, point)
      );
      this.current = point;
      return this;
    }
    addComponent(comp) {
      this.contour.components.push(comp);
      return this;
    }
    addLinearComponent(p1, p2) {
      this.contour.components.push(new LinearPathComponent(p1, p2));
      return this;
    }
    addQuadraticComponent(p1, cp, p2) {
      this.contour.components.push(new QuadraticPathComponent(p1, cp, p2));
      return this;
    }
    addCubicComponent(p1, cp1, cp2, p2) {
      this.contour.components.push(new CubicPathComponent(p1, cp1, cp2, p2));
      return this;
    }
    getLastComponent() {
      return this.contour.getLastComponent();
    }
    length() {
      return this.contours.reduce((acc, c) => acc + c.length(), 0);
    }
    computeTightBounds(result) {
      const bounds = computeTightBounds(
        this.contours.filter((c) => c.components.length > 0)
      );
      result[0] = bounds[0];
      result[1] = bounds[1];
      result[2] = bounds[2];
      result[3] = bounds[3];
    }
    getPoints() {
      const points = [];
      this.contours.forEach((contour) => {
        contour.enumerateComponents(
          (linear) => {
            points.push(linear.p1);
            points.push(linear.p2);
          },
          (quad) => {
            points.push(quad.p1);
            points.push(quad.p2);
            points.push(quad.cp);
          },
          (cubic) => {
            points.push(cubic.p1);
            points.push(cubic.p2);
            points.push(cubic.cp1);
            points.push(cubic.cp2);
          }
        );
      });
      return points;
    }
    getPath2D() {
      const path = new Path2D();
      const cmds = this.toCmds();
      let i = 0;
      while (i < cmds.length) {
        const cmd = cmds[i++];
        if (cmd === 0 /* Move */) {
          const p = new DOMPoint(cmds[i++], cmds[i++]);
          path.moveTo(p.x, p.y);
        } else if (cmd === 1 /* Line */) {
          const p = new DOMPoint(cmds[i++], cmds[i++]);
          path.lineTo(p.x, p.y);
        } else if (cmd === 4 /* Cubic */) {
          const cp1 = new DOMPoint(cmds[i++], cmds[i++]);
          const cp2 = new DOMPoint(cmds[i++], cmds[i++]);
          const p = new DOMPoint(cmds[i++], cmds[i++]);
          path.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, p.x, p.y);
        } else if (cmd === 2 /* Quad */) {
          const cp = new DOMPoint(cmds[i++], cmds[i++]);
          const p = new DOMPoint(cmds[i++], cmds[i++]);
          path.quadraticCurveTo(cp.x, cp.y, p.x, p.y);
        } else if (cmd === 5 /* Close */) {
          path.closePath();
        }
      }
      return path;
    }
    close() {
      if (this.subpathStart) {
        this.lineTo(this.subpathStart);
        this.closeContour();
        this.addContour();
      }
      return this;
    }
    toCmds() {
      return this.contours.flatMap((c) => c.toCmds());
    }
    toSVGString() {
      return this.contours.map((c) => c.toSVGString()).join(" ").trim();
    }
  };

  // src/c2d/Drawable.ts
  var DrawablePath = class {
    constructor(path, fillType = "nonzero") {
      this.path = path;
      this.fillType = fillType;
    }
    draw(ctx, stroke) {
      if (stroke) {
        ctx.stroke(this.path);
      } else {
        ctx.fill(this.path, this.fillType);
      }
    }
  };
  var DrawableText = class {
    constructor(text, x, y, font) {
      this.text = text;
      this.x = x;
      this.y = y;
      this.font = font;
    }
    draw(ctx, stroke) {
      if (this.font) {
        ctx.font = this.font;
      }
      if (stroke) {
        ctx.strokeText(this.text, this.x, this.y);
      } else {
        ctx.fillText(this.text, this.x, this.y);
      }
    }
  };
  var DrawableFill = class {
    topLeft;
    topRight;
    bottomRight;
    bottomLeft;
    constructor(width, height) {
      this.topLeft = new DOMPoint(0, 0);
      this.topRight = new DOMPoint(width, 0);
      this.bottomRight = new DOMPoint(width, height);
      this.bottomLeft = new DOMPoint(0, height);
    }
    draw(ctx, _stroke) {
      const path = new Path2D();
      const ctm = ctx.getTransform().inverse();
      const topLeft = projectPoint(ctm, this.topLeft);
      const topRight = projectPoint(ctm, this.topRight);
      const bottomRight = projectPoint(ctm, this.bottomRight);
      const bottomLeft = projectPoint(ctm, this.bottomLeft);
      path.moveTo(topLeft.x, topLeft.y);
      path.lineTo(topRight.x, topRight.y);
      path.lineTo(bottomRight.x, bottomRight.y);
      path.lineTo(bottomLeft.x, bottomLeft.y);
      path.closePath();
      ctx.fill(path);
    }
  };
  var DrawableImage = class {
    constructor(image, x = 0, y = 0) {
      this.image = image;
      this.x = x;
      this.y = y;
    }
    draw(ctx) {
      ctx.drawImage(this.image, this.x, this.y);
    }
  };
  var DrawableImageRect = class {
    constructor(image, x1, y1, width1, height1, x2, y2, width2, height2) {
      this.image = image;
      this.x1 = x1;
      this.y1 = y1;
      this.width1 = width1;
      this.height1 = height1;
      this.x2 = x2;
      this.y2 = y2;
      this.width2 = width2;
      this.height2 = height2;
    }
    draw(ctx) {
      ctx.drawImage(
        this.image,
        this.x1,
        this.y1,
        this.width1,
        this.height1,
        this.x2,
        this.y2,
        this.width2,
        this.height2
      );
    }
  };
  var DrawableDRRect = class {
    constructor(outer, inner) {
      this.outer = outer;
      this.inner = inner;
    }
    draw(ctx, stroke) {
      const combinedPath = new Path2D();
      combinedPath.addPath(this.outer);
      combinedPath.addPath(this.inner);
      if (stroke) {
        ctx.stroke(combinedPath);
      } else {
        ctx.fill(combinedPath, "evenodd");
      }
    }
  };

  // src/c2d/SVG/SVGFilter.ts
  var ns = "http://www.w3.org/2000/svg";
  var CurrentGraphic = "CurrentGraphic";
  var SourceGraphic = "SourceGraphic";
  var filterId = (filter) => {
    if (filter === CurrentGraphic || filter === SourceGraphic) {
      return filter;
    }
    const id = filter.getAttribute("result");
    if (!id) {
      throw new Error("SVGFilter: id is null");
    }
    return id;
  };
  var makeBlur = (blurX, blurY, inFilter = CurrentGraphic, result = "CurrentGraphic") => {
    const filter = document.createElementNS(ns, "feGaussianBlur");
    filter.setAttribute("in", filterId(inFilter));
    filter.setAttribute("stdDeviation", `${blurX} ${blurY}`);
    filter.setAttribute("result", result);
    return filter;
  };
  var makeComposite = (inFilter, in2Filter, operator, result = "CurrentGraphic") => {
    const filter = document.createElementNS(ns, "feComposite");
    filter.setAttribute("in", filterId(inFilter));
    filter.setAttribute("in2", filterId(in2Filter));
    filter.setAttribute("operator", operator);
    filter.setAttribute("result", result);
    return filter;
  };
  var makeMerge = (inFilters, result = "CurrentGraphic") => {
    const filter = document.createElementNS(ns, "feMerge");
    inFilters.forEach((filterElement) => {
      const mergeNode = document.createElementNS(ns, "feMergeNode");
      mergeNode.setAttribute("in", filterId(filterElement));
      filter.appendChild(mergeNode);
    });
    filter.setAttribute("result", result);
    return filter;
  };
  var makeColorMatrix = (value, input = CurrentGraphic, result = "CurrentGraphic") => {
    const filter = document.createElementNS(ns, "feColorMatrix");
    filter.setAttribute("in", filterId(input));
    filter.setAttribute("type", value.type);
    if (value.type !== "luminanceToAlpha") {
      filter.setAttribute(
        "values",
        Array.isArray(value.values) ? value.values.join(" ") : value.values.toString()
      );
    }
    filter.setAttribute("result", result);
    return filter;
  };

  // src/c2d/SVG/SVGContext.ts
  var SVGContext = class {
    root = document.createElementNS(ns, "svg");
    defs = document.createElementNS(ns, "defs");
    constructor(id) {
      this.root.id = id;
      this.root.style.width = "0";
      this.root.style.height = "0";
      this.defs = document.createElementNS(ns, "defs");
      this.root.appendChild(this.defs);
      document.body.appendChild(this.root);
    }
    dispose() {
      document.body.removeChild(this.root);
    }
    disposeFilter(id) {
      const filter = document.getElementById(id);
      if (filter) {
        this.defs.removeChild(filter);
      }
    }
    discardCacheIfNeeded() {
      if (this.defs.childElementCount > 100) {
        this.disposeFilters();
      }
    }
    disposeFilters() {
      this.root.removeChild(this.defs);
      this.defs = document.createElementNS(ns, "defs");
      this.root.appendChild(this.defs);
    }
    create(id, filters) {
      const url = `url(#${id})`;
      if (document.getElementById(id)) {
        return url;
      }
      const filter = document.createElementNS(ns, "filter");
      filter.setAttribute("id", id);
      for (const fe of filters) {
        filter.appendChild(fe);
      }
      this.defs.appendChild(filter);
      return url;
    }
  };

  // src/c2d/ImageFilter/ImageFilter.ts
  var ImageFilter = class extends IndexedHostObject2 {
    constructor(_filters = []) {
      super("image-filter");
      this._filters = _filters;
    }
    addFilter(filter) {
      this._filters.push(filter);
    }
    get filters() {
      return this._filters;
    }
  };
  var BlurImageFilter = class extends ImageFilter {
    constructor(sigmaX, sigmaY, input = null) {
      super();
      this.sigmaX = sigmaX;
      this.sigmaY = sigmaY;
      this.input = input;
      const blur = makeBlur(sigmaX, sigmaY);
      this._filters.push(blur);
      if (input) {
        this._filters.push(...input.filters);
      }
    }
  };

  // src/c2d/Paint/Paint.ts
  var Paint = class _Paint {
    stroke = false;
    color = "black";
    alpha = 1;
    blendMode = "source-over";
    lineWidth = 1;
    lineCap = "butt";
    lineJoin = "miter";
    miterLimit = 10;
    shader = null;
    imageFilter = null;
    constructor() {
    }
    copy() {
      const paint = new _Paint();
      paint.stroke = this.stroke;
      paint.color = this.color;
      paint.alpha = this.alpha;
      paint.blendMode = this.blendMode;
      paint.lineWidth = this.lineWidth;
      paint.lineCap = this.lineCap;
      paint.lineJoin = this.lineJoin;
      paint.miterLimit = this.miterLimit;
      paint.shader = this.shader;
      paint.imageFilter = this.imageFilter;
      return paint;
    }
    setStrokeStyle(stroke) {
      this.stroke = stroke;
      return this;
    }
    setColor(color2) {
      this.color = color2;
      return this;
    }
    setAlpha(alpha) {
      this.alpha = alpha;
      return this;
    }
    setStrokeWidth(strokeWidth) {
      this.lineWidth = strokeWidth;
      return this;
    }
    getStrokeWidth() {
      return this.lineWidth;
    }
    setStrokeMiter(strokeMiter) {
      this.miterLimit = strokeMiter;
      return this;
    }
    getStrokeMiter() {
      return this.miterLimit;
    }
    getStrokeCap() {
      return this.lineCap;
    }
    getStrokeJoin() {
      return this.lineJoin;
    }
    setStrokeCap(strokeCap) {
      this.lineCap = strokeCap;
      return this;
    }
    setStrokeJoin(strokeJoin) {
      this.lineJoin = strokeJoin;
      return this;
    }
    setBlendMode(blendMode) {
      this.blendMode = blendMode;
      return this;
    }
    setImageFilter(imageFilter) {
      this.imageFilter = imageFilter;
      return this;
    }
    addImageFilter(...imageFilters) {
      if (!this.imageFilter) {
        this.imageFilter = new ImageFilter();
      }
      for (const imageFilter of imageFilters) {
        this.imageFilter.addFilter(imageFilter);
      }
      return this;
    }
    setShader(shader) {
      this.shader = shader;
      return this;
    }
    applyToContext(ctx, svgCtx, ctm, clip, drawable) {
      ctx.save();
      if (clip) {
        ctx.clip(clip);
      }
      ctx.setTransform(ctm);
      ctx.globalAlpha = this.alpha;
      if (this.stroke) {
        ctx.strokeStyle = this.color;
      } else {
        ctx.fillStyle = this.color;
      }
      ctx.lineWidth = this.lineWidth;
      ctx.lineCap = this.lineCap;
      ctx.lineJoin = this.lineJoin;
      ctx.miterLimit = this.miterLimit;
      ctx.globalCompositeOperation = this.blendMode;
      if (this.imageFilter) {
        const { id, filters } = this.imageFilter;
        const url = svgCtx.create(id, filters);
        ctx.filter = url;
      }
      try {
        if (this.shader) {
          const img = this.shader.render(ctx.canvas.width, ctx.canvas.height);
          const pattern = ctx.createPattern(img, "no-repeat");
          if (this.stroke) {
            ctx.strokeStyle = pattern;
          } else {
            ctx.fillStyle = pattern;
          }
        }
      } catch (e) {
      }
      drawable.draw(ctx, this.stroke);
      ctx.restore();
    }
  };

  // src/c2d/Canvas/Canvas.ts
  var Canvas = class extends IndexedHostObject2 {
    stack = [];
    svgCtx;
    constructor(renderingCtx) {
      super("canvas");
      this.stack.push({
        matrix: new DOMMatrix(),
        clip: null,
        imageFilter: null,
        renderingCtx
      });
      this.svgCtx = new SVGContext(this.id);
    }
    get ctx() {
      return this.stack[this.stack.length - 1];
    }
    save(imageFilter) {
      const isLayer = imageFilter !== void 0;
      this.stack.push({
        matrix: DOMMatrix.fromMatrix(this.ctx.matrix),
        clip: this.ctx.clip ? new Path2D(this.ctx.clip) : null,
        imageFilter: imageFilter ?? null,
        renderingCtx: isLayer ? this.makeLayer() : this.ctx.renderingCtx
      });
    }
    concat(matrix) {
      this.ctx.matrix.multiplySelf(matrix);
    }
    resetMatrix() {
      this.ctx.matrix = new DOMMatrix();
    }
    getMatrix() {
      return DOMMatrix.fromMatrix(this.ctx.matrix);
    }
    clip(path) {
      const p = path.getPath2D();
      if (this.ctx.clip) {
        this.ctx.clip.addPath(p);
      } else {
        this.ctx.clip = path.getPath2D();
      }
    }
    restore() {
      const { imageFilter, renderingCtx } = this.ctx;
      this.stack.pop();
      if (imageFilter) {
        const paint = new Paint();
        paint.setImageFilter(imageFilter);
        paint.applyToContext(
          this.ctx.renderingCtx,
          this.svgCtx,
          new DOMMatrix(),
          this.ctx.clip,
          new DrawableImage(
            renderingCtx instanceof OffscreenCanvasRenderingContext2D ? renderingCtx.canvas.transferToImageBitmap() : renderingCtx.canvas
          )
        );
      }
    }
    draw(drawable, paint) {
      paint.applyToContext(
        this.ctx.renderingCtx,
        this.svgCtx,
        this.ctx.matrix,
        this.ctx.clip,
        drawable
      );
    }
    drawPath(path, paint) {
      paint.applyToContext(
        this.ctx.renderingCtx,
        this.svgCtx,
        this.ctx.matrix,
        this.ctx.clip,
        new DrawablePath(path.getPath2D())
      );
    }
    makeLayer() {
      const canvas = new OffscreenCanvas(
        this.ctx.renderingCtx.canvas.width,
        this.ctx.renderingCtx.canvas.height
      );
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        throw new Error("Failed to create canvas context");
      }
      ctx.drawImage(this.ctx.renderingCtx.canvas, 0, 0);
      return ctx;
    }
  };

  // src/c2d/Shader/Shader.ts
  var WebGLShader = class {
    constructor(ctx, uniforms, children, localMatrix) {
      this.ctx = ctx;
      this.children = children;
      this.localMatrix = localMatrix;
      const { gl, program } = ctx;
      const uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
      for (let i = 0; i < uniformCount; i++) {
        const uniformInfo = gl.getActiveUniform(program, i);
        if (!uniformInfo) {
          throw new Error("Could not get uniform info");
        }
        const { name } = uniformInfo;
        if (name === "u_matrix" || name === "u_resolution") {
          continue;
        }
        const location = gl.getUniformLocation(program, name);
        if (!location) {
          throw new Error("Could not get uniform location");
        }
        if (uniformInfo.type === gl.FLOAT) {
          processUniform(
            this.ctx,
            uniforms[name],
            uniformInfo,
            gl.uniform1fv.bind(gl)
          );
        } else if (uniformInfo.type === gl.FLOAT_VEC2) {
          processUniform(
            this.ctx,
            uniforms[name],
            uniformInfo,
            gl.uniform2fv.bind(gl)
          );
        } else if (uniformInfo.type === gl.FLOAT_VEC3) {
          processUniform(
            this.ctx,
            uniforms[name],
            uniformInfo,
            gl.uniform3fv.bind(gl)
          );
        } else if (uniformInfo.type === gl.FLOAT_VEC4) {
          processUniform(
            this.ctx,
            uniforms[name],
            uniformInfo,
            gl.uniform4fv.bind(gl)
          );
        } else if (uniformInfo.type === gl.FLOAT_MAT2) {
          processUniform(
            this.ctx,
            uniforms[name],
            uniformInfo,
            (loc, subarr) => gl.uniformMatrix2fv(loc, false, subarr)
          );
        } else if (uniformInfo.type === gl.FLOAT_MAT3) {
          processUniform(
            this.ctx,
            uniforms[name],
            uniformInfo,
            (loc, subarr) => gl.uniformMatrix3fv(loc, false, subarr)
          );
        } else if (uniformInfo.type === gl.FLOAT_MAT4) {
          processUniform(
            this.ctx,
            uniforms[name],
            uniformInfo,
            (loc, subarr) => gl.uniformMatrix4fv(loc, false, subarr)
          );
        }
      }
    }
    render(width, height) {
      const localMatrix = this.localMatrix ?? new DOMMatrix();
      const { gl, program, textures } = this.ctx;
      gl.canvas.width = width;
      gl.canvas.height = height;
      const matrixLocation = gl.getUniformLocation(program, "u_matrix");
      if (matrixLocation) {
        gl.uniformMatrix4fv(
          matrixLocation,
          false,
          localMatrix.inverse().toFloat32Array()
        );
      }
      const resolutionLocation = gl.getUniformLocation(program, "u_resolution");
      if (resolutionLocation) {
        gl.uniform2f(resolutionLocation, width, height);
      }
      let texIndex = 0;
      const uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
      for (let i = 0; i < uniformCount; i++) {
        const uniformInfo = gl.getActiveUniform(program, i);
        if (!uniformInfo) {
          throw new Error("Could not get uniform info");
        }
        const { name } = uniformInfo;
        const location = gl.getUniformLocation(program, name);
        if (!location) {
          throw new Error("Could not get uniform location");
        }
        if (uniformInfo.type === gl.SAMPLER_2D) {
          if (!this.children[texIndex]) {
            throw new Error(`No texture for uniform ${name}`);
          }
          gl.activeTexture(gl.TEXTURE0 + texIndex);
          gl.bindTexture(gl.TEXTURE_2D, textures[name].texture);
          gl.uniform1i(location, texIndex);
          gl.texImage2D(
            gl.TEXTURE_2D,
            0,
            gl.RGBA,
            gl.RGBA,
            gl.UNSIGNED_BYTE,
            this.children[texIndex].render(width, height)
          );
          texIndex++;
        }
      }
      gl.viewport(0, 0, width, height);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      return gl.canvas;
    }
  };
  var processUniform = (ctx, values, uniformInfo, setter) => {
    const { gl, program } = ctx;
    const { name } = uniformInfo;
    const location = gl.getUniformLocation(program, name);
    if (!location) {
      console.error("Could not find uniform location for " + name);
    }
    setter(gl.getUniformLocation(program, name), values);
  };

  // src/c2d/Shader/ShaderContext.ts
  var vertexShaderCode = `
attribute vec2 a_position;

uniform vec2 u_resolution;

void main() {
  gl_Position = vec4(a_position, 0.0, 1.0);
}
`;
  var handleError = (err, error) => {
    if (error) {
      error(err);
    } else {
      console.error(err);
    }
    return null;
  };
  var WebGLContext = class {
    _gl = null;
    _program = null;
    _textures = null;
    constructor(shaderCode, shaderToy, _error) {
      const canvas = new OffscreenCanvas(0, 0);
      const gl = canvas.getContext("webgl2");
      const error = _error ?? console.error.bind(console);
      if (!gl) {
        handleError(
          "Failed to get WebGL2 context. Your browser or machine may not support it.",
          error
        );
        return;
      }
      const vertexShader = gl.createShader(gl.VERTEX_SHADER);
      const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(vertexShader, vertexShaderCode);
      gl.compileShader(vertexShader);
      gl.shaderSource(
        fragmentShader,
        `precision mediump float;
  
  uniform mat4 u_matrix;
  uniform vec2 u_resolution;
  
  ${shaderCode}
  
  void main() {
    vec4 canvasSpace = gl_FragCoord;
    ${!shaderToy ? "canvasSpace.y = u_resolution.y - canvasSpace.y" : ""};
    vec4 transformedCoord = u_matrix * canvasSpace;
    vec3 transformedCoord3d = transformedCoord.xyz / transformedCoord.w;
    mainImage(gl_FragColor, transformedCoord3d.xy);
  }`
      );
      gl.compileShader(fragmentShader);
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        const info = gl.getShaderInfoLog(fragmentShader);
        const msg = "Could not compile fragment shader. \n" + info;
        handleError(msg, error);
        return;
      }
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        const info = gl.getProgramInfoLog(program);
        const msg = "Could not link WebGL program. \n" + info;
        handleError(msg, error);
        return;
      }
      gl.useProgram(program);
      const textures = {};
      const numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
      for (let i = 0; i < numUniforms; i++) {
        const uniformInfo = gl.getActiveUniform(program, i);
        const location = gl.getUniformLocation(program, uniformInfo.name);
        if (!location) {
          throw new Error("Could not get uniform location");
        }
        if (uniformInfo && uniformInfo.type === gl.SAMPLER_2D) {
          const texture = gl.createTexture();
          gl.activeTexture(gl.TEXTURE0 + i);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          textures[uniformInfo.name] = { texture, location };
        }
      }
      const buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array([
          -1,
          -1,
          1,
          -1,
          -1,
          1,
          -1,
          1,
          1,
          -1,
          1,
          1
        ]),
        gl.STATIC_DRAW
      );
      const positionLocation = gl.getAttribLocation(program, "a_position");
      gl.enableVertexAttribArray(positionLocation);
      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
      this._gl = gl;
      this._program = program;
      this._textures = textures;
    }
    ensureContextIsInitialized() {
      if (!this._gl || !this._program || !this._textures) {
        throw new Error("GLSLContext not initialized.");
      }
    }
    get gl() {
      this.ensureContextIsInitialized();
      return this._gl;
    }
    get program() {
      this.ensureContextIsInitialized();
      return this._program;
    }
    get textures() {
      this.ensureContextIsInitialized();
      return this._textures;
    }
  };

  // src/c2d/Shader/Gradients.ts
  var CustomTexture = class {
    texture = new OffscreenCanvas(0, 0);
    ctx = this.texture.getContext("2d");
    constructor() {
    }
    render(width, height) {
      this.texture.width = width;
      this.texture.height = height;
      this.draw(this.ctx);
      return this.texture;
    }
  };
  var GradientTexture = class extends CustomTexture {
    constructor(colors, pos) {
      super();
      this.colors = colors;
      this.positions = pos ? pos : colors.map((_, i) => i / (colors.length - 1));
    }
    positions;
    draw(ctx) {
      const gradient = this.getGradient(ctx);
      this.colors.forEach((color2, i) => {
        gradient.addColorStop(this.positions[i], color2);
      });
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    }
  };
  var LinearGradient = class extends GradientTexture {
    constructor(start, end, colors, positions) {
      super(colors, positions);
      this.start = start;
      this.end = end;
    }
    getGradient(ctx) {
      const gradient = ctx.createLinearGradient(
        this.start.x,
        this.start.y,
        this.end.x,
        this.end.y
      );
      return gradient;
    }
  };
  var TwoPointConicalGradient = class extends GradientTexture {
    constructor(c1, r1, c2, r2, colors, positions) {
      super(colors, positions);
      this.c1 = c1;
      this.r1 = r1;
      this.c2 = c2;
      this.r2 = r2;
    }
    getGradient(ctx) {
      const gradient = ctx.createRadialGradient(
        this.c1.x,
        this.c1.y,
        this.r1,
        this.c2.x,
        this.c2.y,
        this.r2
      );
      return gradient;
    }
  };
  var SweepGradient = class extends GradientTexture {
    constructor(c, angle, colors, positions) {
      super(colors, positions);
      this.c = c;
      this.angle = angle;
    }
    getGradient(ctx) {
      const gradient = ctx.createConicGradient(this.angle, this.c.x, this.c.y);
      return gradient;
    }
  };

  // src/c2d/Shader/ColorShader.ts
  var ColorShader = class extends CustomTexture {
    constructor(color2) {
      super();
      this.color = color2;
    }
    draw(ctx) {
      ctx.fillStyle = this.color;
      ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    }
  };

  // src/c2d/Shader/BlendShader.ts
  var BlendShader = class extends CustomTexture {
    constructor(blendMode, child1, child2) {
      super();
      this.blendMode = blendMode;
      this.child1 = child1;
      this.child2 = child2;
    }
    draw(ctx) {
      const { width, height } = ctx.canvas;
      const t1 = this.child1.render(width, height);
      ctx.globalCompositeOperation = this.blendMode;
      ctx.drawImage(t1, 0, 0);
      const t2 = this.child2.render(width, height);
      ctx.drawImage(t2, 0, 0);
    }
  };

  // src/c2d/Shader/ImageShader.ts
  var ImageShader = class extends CustomTexture {
    constructor(image, localMatrix) {
      super();
      this.image = image;
      this.localMatrix = localMatrix;
    }
    draw(ctx) {
      if (this.localMatrix) {
        ctx.setTransform(this.localMatrix);
      }
      ctx.drawImage(this.image, 0, 0);
    }
  };

  // src/Core/Values.ts
  var MallocObjJS = class {
    constructor(arr) {
      this.arr = arr;
    }
    byteOffset = 0;
    get length() {
      return this.arr.length;
    }
    subarray(start, end) {
      return this.arr.subarray(start, end);
    }
    toTypedArray() {
      return this.arr;
    }
  };
  var isMalloc = (v) => {
    return typeof v === "object" && v !== null && "toTypedArray" in v;
  };
  var normalizeArray = (arr, Constructor = Float32Array) => {
    if (isMalloc(arr)) {
      return arr.toTypedArray();
    } else if (Array.isArray(arr)) {
      return new Constructor(arr);
    }
    return arr;
  };

  // src/Core/Color.ts
  var color = (r, g, b, a = 1) => new Float32Array([r / 255, g / 255, b / 255, a]);
  var color4f = (r, g, b, a) => Float32Array.of(r, g, b, a ?? 1);
  var clampColorComp = (c) => {
    return Math.round(Math.max(0, Math.min(c || 0, 255)));
  };
  var colorAsInt = (r, g, b, a = 1) => {
    if (a === void 0) {
      a = 255;
    }
    return (clampColorComp(a) << 24 | clampColorComp(r) << 16 | clampColorComp(g) << 8 | clampColorComp(b) << 0 & 268435455) >>> 0;
  };
  var getColorComponents = (cl) => [
    Math.floor(cl[0] * 255),
    Math.floor(cl[1] * 255),
    Math.floor(cl[2] * 255),
    cl[3]
  ];
  var multiplyByAlpha = (c, alpha) => color4f(c[0], c[1], c[2], c[3] * alpha);
  var nativeColor = (inputColor) => {
    const cl = normalizeArray(inputColor);
    return `rgba(${[
      Math.round(cl[0] * 255),
      Math.round(cl[1] * 255),
      Math.round(cl[2] * 255),
      cl[3]
    ].join(", ")})`;
  };
  var normalizeInputColorArray = (input) => {
    if (input instanceof Float32Array || input instanceof Uint32Array) {
      const colors = [];
      for (let i = 0; i < input.length; i += 4) {
        const result = input.subarray(i, i + 4);
        if (result instanceof Float32Array) {
          colors.push(result);
        } else {
          colors.push(
            ...Array.from(result).map((c) => uIntColorToCanvasKitColor(c))
          );
        }
      }
      return colors;
    } else {
      return input;
    }
  };
  var uIntColorToCanvasKitColor = (c) => {
    return Float32Array.of(
      c >> 16 & 255,
      c >> 8 & 255,
      c >> 0 & 255,
      (c >> 24 & 255) / 255
    );
  };
  var intAsColor = (colorInt) => {
    let a = colorInt >>> 24 & 255;
    let r = colorInt >>> 16 & 255;
    let g = colorInt >>> 8 & 255;
    let b = colorInt >>> 0 & 255;
    a = saturate(a / 255);
    r = saturate(r / 255);
    g = saturate(g / 255);
    b = saturate(b / 255);
    return Float32Array.of(r, g, b, a);
  };

  // src/Core/Rect.ts
  var ltrbRect = (left, top, right, bottom) => Float32Array.of(left, top, right, bottom);
  var xywhRect = (x, y, width, height) => ltrbRect(x, y, x + width, y + height);
  var ltrbiRect = (left, top, right, bottom) => Int32Array.of(left, top, right, bottom);
  var xywhiRect = (x, y, width, height) => ltrbiRect(x, y, x + width, y + height);
  var rrectXY = (input, rx, ry) => {
    const rect = normalizeArray(input);
    return Float32Array.of(
      rect[0],
      rect[1],
      rect[2],
      rect[3],
      rx,
      ry,
      rx,
      ry,
      rx,
      ry,
      rx,
      ry
    );
  };
  var rectToXYWH = (r) => {
    const rect = normalizeArray(r);
    return {
      x: rect[0],
      y: rect[1],
      width: rect[2] - rect[0],
      height: rect[3] - rect[1]
    };
  };
  var rrectToXYWH = (r) => {
    const rect = normalizeArray(r);
    return {
      x: rect[0],
      y: rect[1],
      width: rect[2] - rect[0],
      height: rect[3] - rect[1],
      radii: {
        topLeft: vec(rect[4], rect[5]),
        topRight: vec(rect[6], rect[7]),
        bottomRight: vec(rect[8], rect[9]),
        bottomLeft: vec(rect[10], rect[11])
      }
    };
  };
  var rrectToPath2D = (r) => {
    const rect = normalizeArray(r);
    const path = new Path2D();
    path.roundRect(rect[0], rect[1], rect[2] - rect[0], rect[3] - rect[1], [
      { x: rect[4], y: rect[5] },
      { x: rect[6], y: rect[7] },
      { x: rect[8], y: rect[9] },
      { x: rect[10], y: rect[11] }
    ]);
    return path;
  };

  // src/Core/Constants.ts
  var mapKeys = (obj) => Object.keys(obj);
  var makeEnum = (values) => {
    const valueKeys = mapKeys(values).filter((name) => typeof values[name] === "number").map((name) => ({
      name,
      value: values[name]
    }));
    const result = Object.assign(
      {
        values: Object.assign(
          {},
          ...valueKeys.map(({ value }) => ({ [value]: { value } }))
        )
      },
      ...valueKeys.map(({ name, value }) => ({ [name]: { value } }))
    );
    return result;
  };
  var StrokeCapEnum = /* @__PURE__ */ ((StrokeCapEnum2) => {
    StrokeCapEnum2[StrokeCapEnum2["Butt"] = 0] = "Butt";
    StrokeCapEnum2[StrokeCapEnum2["Round"] = 1] = "Round";
    StrokeCapEnum2[StrokeCapEnum2["Square"] = 2] = "Square";
    return StrokeCapEnum2;
  })(StrokeCapEnum || {});
  var StrokeCap = makeEnum(StrokeCapEnum);
  var StrokeJoinEnum = /* @__PURE__ */ ((StrokeJoinEnum2) => {
    StrokeJoinEnum2[StrokeJoinEnum2["Miter"] = 0] = "Miter";
    StrokeJoinEnum2[StrokeJoinEnum2["Round"] = 1] = "Round";
    StrokeJoinEnum2[StrokeJoinEnum2["Bevel"] = 2] = "Bevel";
    return StrokeJoinEnum2;
  })(StrokeJoinEnum || {});
  var StrokeJoin = makeEnum(StrokeJoinEnum);
  var PaintStyleEnum = /* @__PURE__ */ ((PaintStyleEnum2) => {
    PaintStyleEnum2[PaintStyleEnum2["Fill"] = 0] = "Fill";
    PaintStyleEnum2[PaintStyleEnum2["Stroke"] = 1] = "Stroke";
    return PaintStyleEnum2;
  })(PaintStyleEnum || {});
  var PaintStyle = makeEnum(PaintStyleEnum);
  var BlendModeEnum = /* @__PURE__ */ ((BlendModeEnum2) => {
    BlendModeEnum2[BlendModeEnum2["Clear"] = 0] = "Clear";
    BlendModeEnum2[BlendModeEnum2["Src"] = 1] = "Src";
    BlendModeEnum2[BlendModeEnum2["Dst"] = 2] = "Dst";
    BlendModeEnum2[BlendModeEnum2["SrcOver"] = 3] = "SrcOver";
    BlendModeEnum2[BlendModeEnum2["DstOver"] = 4] = "DstOver";
    BlendModeEnum2[BlendModeEnum2["SrcIn"] = 5] = "SrcIn";
    BlendModeEnum2[BlendModeEnum2["DstIn"] = 6] = "DstIn";
    BlendModeEnum2[BlendModeEnum2["SrcOut"] = 7] = "SrcOut";
    BlendModeEnum2[BlendModeEnum2["DstOut"] = 8] = "DstOut";
    BlendModeEnum2[BlendModeEnum2["SrcATop"] = 9] = "SrcATop";
    BlendModeEnum2[BlendModeEnum2["DstATop"] = 10] = "DstATop";
    BlendModeEnum2[BlendModeEnum2["Xor"] = 11] = "Xor";
    BlendModeEnum2[BlendModeEnum2["Plus"] = 12] = "Plus";
    BlendModeEnum2[BlendModeEnum2["Modulate"] = 13] = "Modulate";
    BlendModeEnum2[BlendModeEnum2["Screen"] = 14] = "Screen";
    BlendModeEnum2[BlendModeEnum2["Overlay"] = 15] = "Overlay";
    BlendModeEnum2[BlendModeEnum2["Darken"] = 16] = "Darken";
    BlendModeEnum2[BlendModeEnum2["Lighten"] = 17] = "Lighten";
    BlendModeEnum2[BlendModeEnum2["ColorDodge"] = 18] = "ColorDodge";
    BlendModeEnum2[BlendModeEnum2["ColorBurn"] = 19] = "ColorBurn";
    BlendModeEnum2[BlendModeEnum2["HardLight"] = 20] = "HardLight";
    BlendModeEnum2[BlendModeEnum2["SoftLight"] = 21] = "SoftLight";
    BlendModeEnum2[BlendModeEnum2["Difference"] = 22] = "Difference";
    BlendModeEnum2[BlendModeEnum2["Exclusion"] = 23] = "Exclusion";
    BlendModeEnum2[BlendModeEnum2["Multiply"] = 24] = "Multiply";
    BlendModeEnum2[BlendModeEnum2["Hue"] = 25] = "Hue";
    BlendModeEnum2[BlendModeEnum2["Saturation"] = 26] = "Saturation";
    BlendModeEnum2[BlendModeEnum2["Color"] = 27] = "Color";
    BlendModeEnum2[BlendModeEnum2["Luminosity"] = 28] = "Luminosity";
    return BlendModeEnum2;
  })(BlendModeEnum || {});
  var BlendMode = makeEnum(BlendModeEnum);
  var TileModeEnum = /* @__PURE__ */ ((TileModeEnum2) => {
    TileModeEnum2[TileModeEnum2["Clamp"] = 0] = "Clamp";
    TileModeEnum2[TileModeEnum2["Repeat"] = 1] = "Repeat";
    TileModeEnum2[TileModeEnum2["Mirror"] = 2] = "Mirror";
    TileModeEnum2[TileModeEnum2["Decal"] = 3] = "Decal";
    return TileModeEnum2;
  })(TileModeEnum || {});
  var TileMode = makeEnum(TileModeEnum);
  var FontWeightEnum = /* @__PURE__ */ ((FontWeightEnum2) => {
    FontWeightEnum2[FontWeightEnum2["Invisible"] = 0] = "Invisible";
    FontWeightEnum2[FontWeightEnum2["Thin"] = 100] = "Thin";
    FontWeightEnum2[FontWeightEnum2["ExtraLight"] = 200] = "ExtraLight";
    FontWeightEnum2[FontWeightEnum2["Light"] = 300] = "Light";
    FontWeightEnum2[FontWeightEnum2["Normal"] = 400] = "Normal";
    FontWeightEnum2[FontWeightEnum2["Medium"] = 500] = "Medium";
    FontWeightEnum2[FontWeightEnum2["SemiBold"] = 600] = "SemiBold";
    FontWeightEnum2[FontWeightEnum2["Bold"] = 700] = "Bold";
    FontWeightEnum2[FontWeightEnum2["ExtraBold"] = 800] = "ExtraBold";
    FontWeightEnum2[FontWeightEnum2["Black"] = 900] = "Black";
    FontWeightEnum2[FontWeightEnum2["ExtraBlack"] = 1e3] = "ExtraBlack";
    return FontWeightEnum2;
  })(FontWeightEnum || {});
  var FontWeight = makeEnum(FontWeightEnum);
  var FontWidthEnum = /* @__PURE__ */ ((FontWidthEnum2) => {
    FontWidthEnum2[FontWidthEnum2["UltraCondensed"] = 1] = "UltraCondensed";
    FontWidthEnum2[FontWidthEnum2["ExtraCondensed"] = 2] = "ExtraCondensed";
    FontWidthEnum2[FontWidthEnum2["Condensed"] = 3] = "Condensed";
    FontWidthEnum2[FontWidthEnum2["SemiCondensed"] = 4] = "SemiCondensed";
    FontWidthEnum2[FontWidthEnum2["Normal"] = 5] = "Normal";
    FontWidthEnum2[FontWidthEnum2["SemiExpanded"] = 6] = "SemiExpanded";
    FontWidthEnum2[FontWidthEnum2["Expanded"] = 7] = "Expanded";
    FontWidthEnum2[FontWidthEnum2["ExtraExpanded"] = 8] = "ExtraExpanded";
    FontWidthEnum2[FontWidthEnum2["UltraExpanded"] = 9] = "UltraExpanded";
    return FontWidthEnum2;
  })(FontWidthEnum || {});
  var FontWidth = makeEnum(FontWidthEnum);
  var FontSlantEnum = /* @__PURE__ */ ((FontSlantEnum2) => {
    FontSlantEnum2[FontSlantEnum2["Upright"] = 0] = "Upright";
    FontSlantEnum2[FontSlantEnum2["Italic"] = 1] = "Italic";
    FontSlantEnum2[FontSlantEnum2["Oblique"] = 2] = "Oblique";
    return FontSlantEnum2;
  })(FontSlantEnum || {});
  var FontSlant = makeEnum(FontSlantEnum);
  var FontEdgingEnum = /* @__PURE__ */ ((FontEdgingEnum2) => {
    FontEdgingEnum2[FontEdgingEnum2["Alias"] = 0] = "Alias";
    FontEdgingEnum2[FontEdgingEnum2["AntiAlias"] = 1] = "AntiAlias";
    FontEdgingEnum2[FontEdgingEnum2["SubpixelAntiAlias"] = 2] = "SubpixelAntiAlias";
    return FontEdgingEnum2;
  })(FontEdgingEnum || {});
  var FontEdging = makeEnum(FontEdgingEnum);
  var FontHintingEnum = /* @__PURE__ */ ((FontHintingEnum2) => {
    FontHintingEnum2[FontHintingEnum2["None"] = 0] = "None";
    FontHintingEnum2[FontHintingEnum2["Slight"] = 1] = "Slight";
    FontHintingEnum2[FontHintingEnum2["Normal"] = 2] = "Normal";
    FontHintingEnum2[FontHintingEnum2["Full"] = 3] = "Full";
    return FontHintingEnum2;
  })(FontHintingEnum || {});
  var FontHinting = makeEnum(FontHintingEnum);
  var PointModeEnum = /* @__PURE__ */ ((PointModeEnum2) => {
    PointModeEnum2[PointModeEnum2["Points"] = 0] = "Points";
    PointModeEnum2[PointModeEnum2["Lines"] = 1] = "Lines";
    PointModeEnum2[PointModeEnum2["Polygon"] = 2] = "Polygon";
    return PointModeEnum2;
  })(PointModeEnum || {});
  var PointMode = makeEnum(PointModeEnum);
  var ColorSpaceJS = class extends HostObject {
    constructor(value) {
      super("ColorSpace");
      this.value = value;
    }
    __type__ = "ColorSpace";
    getNativeValue() {
      if (this.value === "adobe-rgb") {
        console.warn(
          "adobe_rgb is not supported on the web, falling back to srgb"
        );
        return "srgb";
      } else {
        return this.value;
      }
    }
  };
  var ColorSpaceEnumJS = class {
    SRGB = new ColorSpaceJS("srgb");
    DISPLAY_P3 = new ColorSpaceJS("display-p3");
    ADOBE_RGB = new ColorSpaceJS("adobe-rgb");
    Equals(a, b) {
      return a.value === b.value;
    }
  };
  var ColorSpace = new ColorSpaceEnumJS();
  var AlphaTypeEnum = /* @__PURE__ */ ((AlphaTypeEnum2) => {
    AlphaTypeEnum2[AlphaTypeEnum2["Opaque"] = 1] = "Opaque";
    AlphaTypeEnum2[AlphaTypeEnum2["Premul"] = 2] = "Premul";
    AlphaTypeEnum2[AlphaTypeEnum2["Unpremul"] = 3] = "Unpremul";
    return AlphaTypeEnum2;
  })(AlphaTypeEnum || {});
  var AlphaType = makeEnum(AlphaTypeEnum);
  var ColorTypeEnum = /* @__PURE__ */ ((ColorTypeEnum2) => {
    ColorTypeEnum2[ColorTypeEnum2["Alpha_8"] = 1] = "Alpha_8";
    ColorTypeEnum2[ColorTypeEnum2["RGB_565"] = 2] = "RGB_565";
    ColorTypeEnum2[ColorTypeEnum2["RGBA_8888"] = 4] = "RGBA_8888";
    ColorTypeEnum2[ColorTypeEnum2["BGRA_8888"] = 6] = "BGRA_8888";
    ColorTypeEnum2[ColorTypeEnum2["RGBA_1010102"] = 7] = "RGBA_1010102";
    ColorTypeEnum2[ColorTypeEnum2["RGB_101010x"] = 9] = "RGB_101010x";
    ColorTypeEnum2[ColorTypeEnum2["Gray_8"] = 12] = "Gray_8";
    ColorTypeEnum2[ColorTypeEnum2["RGBA_F16"] = 14] = "RGBA_F16";
    ColorTypeEnum2[ColorTypeEnum2["RGBA_F32"] = 15] = "RGBA_F32";
    return ColorTypeEnum2;
  })(ColorTypeEnum || {});
  var ColorType = makeEnum(ColorTypeEnum);
  var FilterModeEnum = /* @__PURE__ */ ((FilterModeEnum2) => {
    FilterModeEnum2[FilterModeEnum2["Nearest"] = 0] = "Nearest";
    FilterModeEnum2[FilterModeEnum2["Linear"] = 1] = "Linear";
    return FilterModeEnum2;
  })(FilterModeEnum || {});
  var FilterMode = makeEnum(FilterModeEnum);
  var MipmapModeEnum = /* @__PURE__ */ ((MipmapModeEnum2) => {
    MipmapModeEnum2[MipmapModeEnum2["None"] = 0] = "None";
    MipmapModeEnum2[MipmapModeEnum2["Nearest"] = 1] = "Nearest";
    MipmapModeEnum2[MipmapModeEnum2["Linear"] = 2] = "Linear";
    return MipmapModeEnum2;
  })(MipmapModeEnum || {});
  var MipmapMode = makeEnum(MipmapModeEnum);
  var ImageFormatEnum = /* @__PURE__ */ ((ImageFormatEnum2) => {
    ImageFormatEnum2[ImageFormatEnum2["JPEG"] = 3] = "JPEG";
    ImageFormatEnum2[ImageFormatEnum2["PNG"] = 4] = "PNG";
    ImageFormatEnum2[ImageFormatEnum2["WEBP"] = 6] = "WEBP";
    return ImageFormatEnum2;
  })(ImageFormatEnum || {});
  var ImageFormat = makeEnum(ImageFormatEnum);
  var PathOpEnum = /* @__PURE__ */ ((PathOpEnum2) => {
    PathOpEnum2[PathOpEnum2["Difference"] = 0] = "Difference";
    PathOpEnum2[PathOpEnum2["Intersect"] = 1] = "Intersect";
    PathOpEnum2[PathOpEnum2["Union"] = 2] = "Union";
    PathOpEnum2[PathOpEnum2["XOR"] = 3] = "XOR";
    PathOpEnum2[PathOpEnum2["ReverseDifference"] = 4] = "ReverseDifference";
    return PathOpEnum2;
  })(PathOpEnum || {});
  var PathOp = makeEnum(PathOpEnum);
  var FillTypeEnum = /* @__PURE__ */ ((FillTypeEnum2) => {
    FillTypeEnum2[FillTypeEnum2["Winding"] = 0] = "Winding";
    FillTypeEnum2[FillTypeEnum2["EvenOdd"] = 1] = "EvenOdd";
    return FillTypeEnum2;
  })(FillTypeEnum || {});
  var FillType = makeEnum(FillTypeEnum);
  var Path1DEffectStyleEnum = /* @__PURE__ */ ((Path1DEffectStyleEnum2) => {
    Path1DEffectStyleEnum2[Path1DEffectStyleEnum2["Translate"] = 0] = "Translate";
    Path1DEffectStyleEnum2[Path1DEffectStyleEnum2["Rotate"] = 1] = "Rotate";
    Path1DEffectStyleEnum2[Path1DEffectStyleEnum2["Morph"] = 2] = "Morph";
    return Path1DEffectStyleEnum2;
  })(Path1DEffectStyleEnum || {});
  var Path1DEffectStyle = makeEnum(
    Path1DEffectStyleEnum
  );
  var BlurStyleEnum = /* @__PURE__ */ ((BlurStyleEnum2) => {
    BlurStyleEnum2[BlurStyleEnum2["Normal"] = 0] = "Normal";
    BlurStyleEnum2[BlurStyleEnum2["Solid"] = 1] = "Solid";
    BlurStyleEnum2[BlurStyleEnum2["Outer"] = 2] = "Outer";
    BlurStyleEnum2[BlurStyleEnum2["Inner"] = 3] = "Inner";
    return BlurStyleEnum2;
  })(BlurStyleEnum || {});
  var BlurStyle = makeEnum(BlurStyleEnum);
  var VertexModeEnum = /* @__PURE__ */ ((VertexModeEnum2) => {
    VertexModeEnum2[VertexModeEnum2["Triangles"] = 0] = "Triangles";
    VertexModeEnum2[VertexModeEnum2["TrianglesStrip"] = 1] = "TrianglesStrip";
    VertexModeEnum2[VertexModeEnum2["TriangleFan"] = 2] = "TriangleFan";
    return VertexModeEnum2;
  })(VertexModeEnum || {});
  var VertexMode = makeEnum(VertexModeEnum);
  var ClipOpEnum = /* @__PURE__ */ ((ClipOpEnum2) => {
    ClipOpEnum2[ClipOpEnum2["Difference"] = 0] = "Difference";
    ClipOpEnum2[ClipOpEnum2["Intersect"] = 1] = "Intersect";
    return ClipOpEnum2;
  })(ClipOpEnum || {});
  var ClipOp = makeEnum(ClipOpEnum);
  var TextAlignEnum = /* @__PURE__ */ ((TextAlignEnum2) => {
    TextAlignEnum2[TextAlignEnum2["Left"] = 0] = "Left";
    TextAlignEnum2[TextAlignEnum2["Right"] = 1] = "Right";
    TextAlignEnum2[TextAlignEnum2["Center"] = 2] = "Center";
    TextAlignEnum2[TextAlignEnum2["Justify"] = 3] = "Justify";
    TextAlignEnum2[TextAlignEnum2["Start"] = 4] = "Start";
    TextAlignEnum2[TextAlignEnum2["End"] = 5] = "End";
    return TextAlignEnum2;
  })(TextAlignEnum || {});
  var TextAlign = makeEnum(TextAlignEnum);
  var TextBaselineEnum = /* @__PURE__ */ ((TextBaselineEnum2) => {
    TextBaselineEnum2[TextBaselineEnum2["Alphabetic"] = 0] = "Alphabetic";
    TextBaselineEnum2[TextBaselineEnum2["Ideographic"] = 1] = "Ideographic";
    return TextBaselineEnum2;
  })(TextBaselineEnum || {});
  var TextBaseline = makeEnum(TextBaselineEnum);
  var TextDirectionEnum = /* @__PURE__ */ ((TextDirectionEnum2) => {
    TextDirectionEnum2[TextDirectionEnum2["RTL"] = 0] = "RTL";
    TextDirectionEnum2[TextDirectionEnum2["LTR"] = 1] = "LTR";
    return TextDirectionEnum2;
  })(TextDirectionEnum || {});
  var TextDirection = makeEnum(TextDirectionEnum);
  var TextHeightBehaviorEnum = /* @__PURE__ */ ((TextHeightBehaviorEnum2) => {
    TextHeightBehaviorEnum2[TextHeightBehaviorEnum2["All"] = 0] = "All";
    TextHeightBehaviorEnum2[TextHeightBehaviorEnum2["DisableFirstAscent"] = 1] = "DisableFirstAscent";
    TextHeightBehaviorEnum2[TextHeightBehaviorEnum2["DisableLastDescent"] = 2] = "DisableLastDescent";
    TextHeightBehaviorEnum2[TextHeightBehaviorEnum2["DisableAll"] = 3] = "DisableAll";
    return TextHeightBehaviorEnum2;
  })(TextHeightBehaviorEnum || {});
  var TextHeightBehavior = makeEnum(
    TextHeightBehaviorEnum
  );
  var DecorationStyleEnum = /* @__PURE__ */ ((DecorationStyleEnum2) => {
    DecorationStyleEnum2[DecorationStyleEnum2["Solid"] = 0] = "Solid";
    DecorationStyleEnum2[DecorationStyleEnum2["Double"] = 1] = "Double";
    DecorationStyleEnum2[DecorationStyleEnum2["Dotted"] = 2] = "Dotted";
    DecorationStyleEnum2[DecorationStyleEnum2["Dashed"] = 3] = "Dashed";
    DecorationStyleEnum2[DecorationStyleEnum2["Wavy"] = 4] = "Wavy";
    return DecorationStyleEnum2;
  })(DecorationStyleEnum || {});
  var DecorationStyle = makeEnum(DecorationStyleEnum);
  var AffinityEnum = /* @__PURE__ */ ((AffinityEnum2) => {
    AffinityEnum2[AffinityEnum2["Upstream"] = 0] = "Upstream";
    AffinityEnum2[AffinityEnum2["Downstream"] = 1] = "Downstream";
    return AffinityEnum2;
  })(AffinityEnum || {});
  var Affinity = makeEnum(AffinityEnum);
  var ColorChannelEnum = /* @__PURE__ */ ((ColorChannelEnum2) => {
    ColorChannelEnum2[ColorChannelEnum2["Red"] = 0] = "Red";
    ColorChannelEnum2[ColorChannelEnum2["Green"] = 1] = "Green";
    ColorChannelEnum2[ColorChannelEnum2["Blue"] = 2] = "Blue";
    ColorChannelEnum2[ColorChannelEnum2["Alpha"] = 3] = "Alpha";
    return ColorChannelEnum2;
  })(ColorChannelEnum || {});
  var ColorChannel = makeEnum(ColorChannelEnum);
  var PlaceholderAlignmentEnum = /* @__PURE__ */ ((PlaceholderAlignmentEnum2) => {
    PlaceholderAlignmentEnum2[PlaceholderAlignmentEnum2["Baseline"] = 0] = "Baseline";
    PlaceholderAlignmentEnum2[PlaceholderAlignmentEnum2["AboveBaseline"] = 1] = "AboveBaseline";
    PlaceholderAlignmentEnum2[PlaceholderAlignmentEnum2["BelowBaseline"] = 2] = "BelowBaseline";
    PlaceholderAlignmentEnum2[PlaceholderAlignmentEnum2["Top"] = 3] = "Top";
    PlaceholderAlignmentEnum2[PlaceholderAlignmentEnum2["Bottom"] = 4] = "Bottom";
    PlaceholderAlignmentEnum2[PlaceholderAlignmentEnum2["Middle"] = 5] = "Middle";
    return PlaceholderAlignmentEnum2;
  })(PlaceholderAlignmentEnum || {});
  var PlaceholderAlignment = makeEnum(
    PlaceholderAlignmentEnum
  );
  var RectHeightStyleEnum = /* @__PURE__ */ ((RectHeightStyleEnum2) => {
    RectHeightStyleEnum2[RectHeightStyleEnum2["Tight"] = 0] = "Tight";
    RectHeightStyleEnum2[RectHeightStyleEnum2["Max"] = 1] = "Max";
    RectHeightStyleEnum2[RectHeightStyleEnum2["IncludeLineSpacingMiddle"] = 2] = "IncludeLineSpacingMiddle";
    RectHeightStyleEnum2[RectHeightStyleEnum2["IncludeLineSpacingTop"] = 3] = "IncludeLineSpacingTop";
    RectHeightStyleEnum2[RectHeightStyleEnum2["IncludeLineSpacingBottom"] = 4] = "IncludeLineSpacingBottom";
    RectHeightStyleEnum2[RectHeightStyleEnum2["Strut"] = 5] = "Strut";
    return RectHeightStyleEnum2;
  })(RectHeightStyleEnum || {});
  var RectHeightStyle = makeEnum(RectHeightStyleEnum);
  var RectWidthStyleEnum = /* @__PURE__ */ ((RectWidthStyleEnum2) => {
    RectWidthStyleEnum2[RectWidthStyleEnum2["Tight"] = 0] = "Tight";
    RectWidthStyleEnum2[RectWidthStyleEnum2["Max"] = 1] = "Max";
    return RectWidthStyleEnum2;
  })(RectWidthStyleEnum || {});
  var RectWidthStyle = makeEnum(RectWidthStyleEnum);

  // src/Core/Matrix/Matrix3.ts
  var toDOMMatrix3x2 = (m3) => {
    const m = new DOMMatrix();
    m.a = m3[0];
    m.b = m3[3];
    m.c = m3[1];
    m.d = m3[4];
    m.e = m3[2];
    m.f = m3[5];
    return m;
  };
  var toDOMMatrix3 = (m3) => {
    const m = new DOMMatrix();
    m.m11 = m3[0];
    m.m21 = m3[1];
    m.m41 = m3[2];
    m.m12 = m3[3];
    m.m22 = m3[4];
    m.m42 = m3[5];
    m.m14 = m3[6];
    m.m24 = m3[7];
    m.m44 = m3[8];
    return m;
  };
  var toDOMMatrix4 = (m3) => {
    const m = new DOMMatrix();
    m.m11 = m3[0];
    m.m21 = m3[1];
    m.m31 = m3[2];
    m.m41 = m3[3];
    m.m12 = m3[4];
    m.m22 = m3[5];
    m.m32 = m3[6];
    m.m42 = m3[7];
    m.m13 = m3[8];
    m.m23 = m3[9];
    m.m33 = m3[10];
    m.m43 = m3[11];
    m.m14 = m3[12];
    m.m24 = m3[13];
    m.m34 = m3[14];
    m.m44 = m3[15];
    return m;
  };
  var nativeMatrix = (matrix) => {
    if (matrix instanceof DOMMatrix) {
      return matrix;
    }
    const m3 = normalizeArray(matrix);
    if (m3.length === 6) {
      return toDOMMatrix3x2(m3);
    } else if (m3.length === 9) {
      return toDOMMatrix3(m3);
    } else if (m3.length === 16) {
      return toDOMMatrix4(m3);
    }
    throw new Error("Invalid matrix");
  };
  var transformPoint = (matrix, ...point) => {
    const x = matrix[0] * point[0] + matrix[1] * point[1] + matrix[2] * 1;
    const y = matrix[3] * point[0] + matrix[4] * point[1] + matrix[5] * 1;
    const w = matrix[6] * point[0] + matrix[7] * point[1] + matrix[8] * 1;
    return new DOMPoint(x / w, y / w);
  };
  var Matrix3 = {
    identity() {
      return [1, 0, 0, 0, 1, 0, 0, 0, 1];
    },
    invert(m) {
      const [a, b, c, d, e, f, g, h, i] = m;
      const det = a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);
      if (det === 0) {
        return null;
      }
      return [
        (e * i - f * h) / det,
        (c * h - b * i) / det,
        (b * f - c * e) / det,
        (f * g - d * i) / det,
        (a * i - c * g) / det,
        (c * d - a * f) / det,
        (d * h - e * g) / det,
        (b * g - a * h) / det,
        (a * e - b * d) / det
      ];
    },
    mapPoints(m, points) {
      const [a, b, c, d, e, f] = m;
      for (let j = 0; j < points.length; j += 2) {
        const x = points[j], y = points[j + 1];
        points[j] = a * x + b * y + c;
        points[j + 1] = d * x + e * y + f;
      }
      return points;
    },
    multiply(...matrices) {
      let result = this.identity();
      for (const m of matrices) {
        const temp = this.identity();
        for (let i = 0; i < 3; ++i) {
          for (let j = 0; j < 3; ++j) {
            temp[i * 3 + j] = 0;
            for (let k = 0; k < 3; ++k) {
              temp[i * 3 + j] += result[i * 3 + k] * m[k * 3 + j];
            }
          }
        }
        result = temp;
      }
      return result;
    },
    rotated(radians, px = 0, py = 0) {
      const c = Math.cos(radians);
      const s = Math.sin(radians);
      return [c, -s, px * (1 - c) + py * s, s, c, py * (1 - c) - px * s, 0, 0, 1];
    },
    scaled(sx, sy, px = 0, py = 0) {
      return [sx, 0, px * (1 - sx), 0, sy, py * (1 - sy), 0, 0, 1];
    },
    skewed(kx, ky, px = 0, py = 0) {
      return [1, kx, -px * kx, ky, 1, -py * ky, 0, 0, 1];
    },
    translated(dx, dy) {
      return [1, 0, dx, 0, 1, dy, 0, 0, 1];
    }
  };

  // src/Core/Matrix/Matrix4.ts
  var Matrix4 = {
    identity: function() {
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    },
    invert: function(_matrix) {
      throw new Error("Function not implemented.");
    },
    lookat: function(_eyeVec, _centerVec, _upVec) {
      throw new Error("Function not implemented.");
    },
    multiply: function(...matrices) {
      let result = this.identity();
      for (const m of matrices) {
        const temp = this.identity();
        for (let i = 0; i < 4; ++i) {
          for (let j = 0; j < 4; ++j) {
            temp[i * 4 + j] = 0;
            for (let k = 0; k < 4; ++k) {
              temp[i * 4 + j] += result[i * 4 + k] * m[k * 4 + j];
            }
          }
        }
        result = temp;
      }
      return result;
    },
    mustInvert: function(_matrix) {
      throw new Error("Function not implemented.");
    },
    perspective: function(_near, _far, _radians) {
      throw new Error("Function not implemented.");
    },
    rc: function(_matrix, _row, _col) {
      throw new Error("Function not implemented.");
    },
    rotated: function(_axisVec, _radians) {
      throw new Error("Function not implemented.");
    },
    rotatedUnitSinCos: function(axisVec, sinAngle, cosAngle) {
      const x = axisVec[0];
      const y = axisVec[1];
      const z = axisVec[2];
      const c = cosAngle;
      const s = sinAngle;
      const t = 1 - c;
      return [
        t * x * x + c,
        t * x * y - s * z,
        t * x * z + s * y,
        0,
        t * x * y + s * z,
        t * y * y + c,
        t * y * z - s * x,
        0,
        t * x * z - s * y,
        t * y * z + s * x,
        t * z * z + c,
        0,
        0,
        0,
        0,
        1
      ];
    },
    scaled: function(_vec) {
      throw new Error("Function not implemented.");
    },
    setupCamera: function(_area, _zScale, _cam) {
      throw new Error("Function not implemented.");
    },
    translated: function(_vec) {
      throw new Error("Function not implemented.");
    },
    transpose: function(_matrix) {
      throw new Error("Function not implemented.");
    }
  };

  // src/Core/Vector.ts
  var nativePoint = (pt) => new DOMPoint(...pt);
  var VectorHelpers = {
    add: function(a, b) {
      return a.map(function(v, i) {
        return v + b[i];
      });
    },
    cross: function(a, b) {
      return [
        a[1] * b[2] - a[2] * b[1],
        a[2] * b[0] - a[0] * b[2],
        a[0] * b[1] - a[1] * b[0]
      ];
    },
    dist: function(a, b) {
      return this.length(this.sub(a, b));
    },
    dot: function(a, b) {
      return a.map(function(v, i) {
        return v * b[i];
      }).reduce(function(acc, cur) {
        return acc + cur;
      });
    },
    length: function(v) {
      return Math.sqrt(this.lengthSquared(v));
    },
    lengthSquared: function(v) {
      return this.dot(v, v);
    },
    mulScalar: (v, s) => v.map((i) => i * s),
    normalize: function(v) {
      return this.mulScalar(v, 1 / this.length(v));
    },
    sub: (a, b) => a.map((v, i) => v - b[i])
  };

  // src/Core/CoreCanvasKit.ts
  var CoreCanvasKit = class {
    Color(r, g, b, a = 1) {
      return color(r, g, b, a);
    }
    Color4f(r, g, b, a) {
      return color4f(r, g, b, a);
    }
    ColorAsInt(r, g, b, a = 1) {
      return colorAsInt(r, g, b, a);
    }
    getColorComponents(cl) {
      return getColorComponents(cl);
    }
    multiplyByAlpha(c, alpha) {
      return multiplyByAlpha(c, alpha);
    }
    LTRBRect(left, top, right, bottom) {
      return ltrbRect(left, top, right, bottom);
    }
    XYWHRect(x, y, width, height) {
      return xywhRect(x, y, width, height);
    }
    LTRBiRect(left, top, right, bottom) {
      return ltrbiRect(left, top, right, bottom);
    }
    XYWHiRect(x, y, width, height) {
      return xywhiRect(x, y, width, height);
    }
    RRectXY(input, rx, ry) {
      return rrectXY(input, rx, ry);
    }
    Vector = VectorHelpers;
    ImageFormat = ImageFormat;
    MipmapMode = MipmapMode;
    PaintStyle = PaintStyle;
    Path1DEffect = Path1DEffectStyle;
    PathOp = PathOp;
    PointMode = PointMode;
    ColorSpace = ColorSpace;
    StrokeCap = StrokeCap;
    StrokeJoin = StrokeJoin;
    TileMode = TileMode;
    VertexMode = VertexMode;
    FontSlant = FontSlant;
    FontWeight = FontWeight;
    FontWidth = FontWidth;
    ColorType = ColorType;
    FillType = FillType;
    FilterMode = FilterMode;
    FontEdging = FontEdging;
    FontHinting = FontHinting;
    AlphaType = AlphaType;
    BlendMode = BlendMode;
    BlurStyle = BlurStyle;
    ClipOp = ClipOp;
    Matrix = Matrix3;
    M44 = Matrix4;
    Affinity = Affinity;
    TRANSPARENT = Float32Array.of(0, 0, 0, 0);
    BLACK = Float32Array.of(0, 0, 0, 1);
    WHITE = Float32Array.of(1, 1, 1, 1);
    RED = Float32Array.of(1, 0, 0, 1);
    GREEN = Float32Array.of(0, 1, 0, 1);
    BLUE = Float32Array.of(0, 0, 1, 1);
    YELLOW = Float32Array.of(1, 1, 0, 1);
    CYAN = Float32Array.of(0, 1, 1, 1);
    MAGENTA = Float32Array.of(1, 0, 1, 1);
    MOVE_VERB = 0 /* Move */;
    LINE_VERB = 1 /* Line */;
    QUAD_VERB = 2 /* Quad */;
    CONIC_VERB = 3 /* Conic */;
    CUBIC_VERB = 4 /* Cubic */;
    CLOSE_VERB = 5 /* Close */;
    GlyphRunFlags = {
      IsWhiteSpace: 1
    };
    TextAlign = TextAlign;
    TextBaseline = TextBaseline;
    TextDirection = TextDirection;
    TextHeightBehavior = TextHeightBehavior;
    PlaceholderAlignment = PlaceholderAlignment;
    RectHeightStyle = RectHeightStyle;
    RectWidthStyle = RectWidthStyle;
    ColorChannel = ColorChannel;
    LineThroughDecoration = 4;
    NoDecoration = 0;
    UnderlineDecoration = 1;
    OverlineDecoration = 2;
    ShadowTransparentOccluder = 1;
    ShadowGeometricOnly = 2;
    ShadowDirectionalLight = 4;
    DecorationStyle = DecorationStyle;
    gpu = true;
    polyfill = true;
    managed_skottie = false;
    rt_effect = true;
    skottie = false;
    SaveLayerInitWithPrevious = 1 << 2;
    SaveLayerF16ColorType = 1 << 4;
  };

  // src/Canvas/CanvasRecorder.ts
  var RecordingContext = class {
    saveCount = 0;
    save() {
      return this.saveCount++;
    }
    restore() {
      this.saveCount--;
    }
  };
  var CanvasRecorder = class extends HostObject {
    constructor(bounds) {
      super("Canvas");
      this.bounds = bounds;
    }
    ctx = new RecordingContext();
    commands = [];
    replay(canvas) {
      this.commands.forEach((cmd) => {
        canvas[cmd.name](...cmd.args);
      });
    }
    clear(color2) {
      this.commands.push({ name: "clear", args: [color2] });
    }
    clipPath(path, op, doAntiAlias) {
      this.commands.push({ name: "clipPath", args: [path, op, doAntiAlias] });
    }
    clipRect(rect, op, doAntiAlias) {
      this.commands.push({ name: "clipRect", args: [rect, op, doAntiAlias] });
    }
    clipRRect(rrect, op, doAntiAlias) {
      this.commands.push({ name: "clipRRect", args: [rrect, op, doAntiAlias] });
    }
    concat(m) {
      this.commands.push({ name: "concat", args: [m] });
    }
    drawArc(oval, startAngle, sweepAngle, useCenter, paint) {
      this.commands.push({
        name: "drawArc",
        args: [oval, startAngle, sweepAngle, useCenter, paint]
      });
    }
    drawAtlas(atlas, srcRects, dstXforms, paint, blendMode, colors, sampling) {
      this.commands.push({
        name: "drawAtlas",
        args: [atlas, srcRects, dstXforms, paint, blendMode, colors, sampling]
      });
    }
    drawCircle(cx, cy, radius, paint) {
      this.commands.push({ name: "drawCircle", args: [cx, cy, radius, paint] });
    }
    drawColor(color2, blendMode) {
      this.commands.push({ name: "drawColor", args: [color2, blendMode] });
    }
    drawColorComponents(r, g, b, a, blendMode) {
      this.commands.push({
        name: "drawColorComponents",
        args: [r, g, b, a, blendMode]
      });
    }
    drawColorInt(color2, blendMode) {
      this.commands.push({ name: "drawColorInt", args: [color2, blendMode] });
    }
    drawDRRect(outer, inner, paint) {
      this.commands.push({ name: "drawDRRect", args: [outer, inner, paint] });
    }
    drawGlyphs(glyphs, positions, x, y, font, paint) {
      this.commands.push({
        name: "drawGlyphs",
        args: [glyphs, positions, x, y, font, paint]
      });
    }
    drawImage(img, left, top, paint) {
      this.commands.push({ name: "drawImage", args: [img, left, top, paint] });
    }
    drawImageCubic(img, left, top, B, C, paint) {
      this.commands.push({
        name: "drawImageCubic",
        args: [img, left, top, B, C, paint]
      });
    }
    drawImageOptions(img, left, top, fm, mm, paint) {
      this.commands.push({
        name: "drawImageOptions",
        args: [img, left, top, fm, mm, paint]
      });
    }
    drawImageNine(img, center, dest, filter, paint) {
      this.commands.push({
        name: "drawImageNine",
        args: [img, center, dest, filter, paint]
      });
    }
    drawImageRect(img, src, dest, paint, fastSample) {
      this.commands.push({
        name: "drawImageRect",
        args: [img, src, dest, paint, fastSample]
      });
    }
    drawImageRectCubic(img, src, dest, B, C, paint) {
      this.commands.push({
        name: "drawImageRectCubic",
        args: [img, src, dest, B, C, paint]
      });
    }
    drawImageRectOptions(img, src, dest, fm, mm, paint) {
      this.commands.push({
        name: "drawImageRectOptions",
        args: [img, src, dest, fm, mm, paint]
      });
    }
    drawLine(x0, y0, x1, y1, paint) {
      this.commands.push({ name: "drawLine", args: [x0, y0, x1, y1, paint] });
    }
    drawOval(oval, paint) {
      this.commands.push({ name: "drawOval", args: [oval, paint] });
    }
    drawPaint(paint) {
      this.commands.push({ name: "drawPaint", args: [paint] });
    }
    drawParagraph(p, x, y) {
      this.commands.push({ name: "drawParagraph", args: [p, x, y] });
    }
    drawPath(path, paint) {
      this.commands.push({ name: "drawPath", args: [path, paint] });
    }
    drawPatch(cubics, colors, texs, mode, paint) {
      this.commands.push({
        name: "drawPatch",
        args: [cubics, colors, texs, mode, paint]
      });
    }
    drawPicture(skp) {
      this.commands.push({ name: "drawPicture", args: [skp] });
    }
    drawPoints(mode, points, paint) {
      this.commands.push({ name: "drawPoints", args: [mode, points, paint] });
    }
    drawRect(rect, paint) {
      this.commands.push({ name: "drawRect", args: [rect, paint] });
    }
    drawRect4f(left, top, right, bottom, paint) {
      this.commands.push({
        name: "drawRect4f",
        args: [left, top, right, bottom, paint]
      });
    }
    drawRRect(rrect, paint) {
      this.commands.push({ name: "drawRRect", args: [rrect, paint] });
    }
    drawShadow(path, zPlaneParams, lightPos, lightRadius, ambientColor, spotColor, flags) {
      this.commands.push({
        name: "drawShadow",
        args: [
          path,
          zPlaneParams,
          lightPos,
          lightRadius,
          ambientColor,
          spotColor,
          flags
        ]
      });
    }
    drawText(str, x, y, paint, font) {
      this.commands.push({ name: "drawText", args: [str, x, y, paint, font] });
    }
    drawTextBlob(blob, x, y, paint) {
      this.commands.push({ name: "drawTextBlob", args: [blob, x, y, paint] });
    }
    drawVertices(verts, mode, paint) {
      this.commands.push({ name: "drawVertices", args: [verts, mode, paint] });
    }
    getDeviceClipBounds(output) {
      this.commands.push({ name: "getDeviceClipBounds", args: [output] });
      throw new Error("This method returns a value, hence can't be recorded.");
    }
    getLocalToDevice() {
      this.commands.push({ name: "getLocalToDevice", args: [] });
      throw new Error("This method returns a value, hence can't be recorded.");
    }
    getSaveCount() {
      this.commands.push({ name: "getSaveCount", args: [] });
      throw new Error("This method returns a value, hence can't be recorded.");
    }
    getTotalMatrix() {
      this.commands.push({ name: "getTotalMatrix", args: [] });
      throw new Error("This method returns a value, hence can't be recorded.");
    }
    makeSurface(info) {
      this.commands.push({ name: "makeSurface", args: [info] });
      throw new Error("This method returns a value, hence can't be recorded.");
    }
    readPixels(srcX, srcY, imageInfo, dest, bytesPerRow) {
      this.commands.push({
        name: "readPixels",
        args: [srcX, srcY, imageInfo, dest, bytesPerRow]
      });
      return null;
    }
    restore() {
      this.commands.push({ name: "restore", args: [] });
      this.ctx.restore();
    }
    restoreToCount(saveCount) {
      this.commands.push({ name: "restoreToCount", args: [saveCount] });
      for (let i = 1; i <= saveCount; i++) {
        this.restore();
      }
    }
    rotate(rot, rx, ry) {
      this.commands.push({ name: "rotate", args: [rot, rx, ry] });
    }
    save() {
      this.commands.push({ name: "save", args: [] });
      return this.ctx.save();
    }
    saveLayer(paint, bounds, backdrop, flags) {
      this.commands.push({
        name: "saveLayer",
        args: [paint, bounds, backdrop, flags]
      });
      return this.ctx.save();
    }
    scale(sx, sy) {
      this.commands.push({ name: "scale", args: [sx, sy] });
    }
    skew(sx, sy) {
      this.commands.push({ name: "skew", args: [sx, sy] });
    }
    translate(dx, dy) {
      this.commands.push({ name: "translate", args: [dx, dy] });
    }
    writePixels(pixels, srcWidth, srcHeight, destX, destY, alphaType, colorType, colorSpace) {
      this.commands.push({
        name: "writePixels",
        args: [
          pixels,
          srcWidth,
          srcHeight,
          destX,
          destY,
          alphaType,
          colorType,
          colorSpace
        ]
      });
      return false;
    }
  };

  // src/Paint/BlendMode.ts
  var nativeBlendMode = (mode) => {
    const blendModesMap = {
      0: "copy",
      // Clear
      1: "copy",
      // Src
      2: "destination-over",
      // Dst
      3: "source-over",
      // SrcOver
      4: "destination-over",
      // DstOver
      5: "source-in",
      // SrcIn
      6: "destination-in",
      // DstIn
      7: "source-out",
      // SrcOut
      8: "destination-out",
      // DstOut
      9: "source-atop",
      // SrcATop
      10: "destination-atop",
      // DstATop
      11: "xor",
      // Xor
      12: "lighter",
      // Plus
      13: "multiply",
      // Modulate (closest match)
      14: "screen",
      // Screen
      15: "overlay",
      // Overlay
      16: "darken",
      // Darken
      17: "lighten",
      // Lighten
      18: "color-dodge",
      // ColorDodge
      19: "color-burn",
      // ColorBurn
      20: "hard-light",
      // HardLight
      21: "soft-light",
      // SoftLight
      22: "difference",
      // Difference
      23: "exclusion",
      // Exclusion
      24: "multiply",
      // Multiply
      25: "hue",
      // Hue
      26: "saturation",
      // Saturation
      27: "color",
      // Color
      28: "luminosity"
      // Luminosity
    };
    const val = blendModesMap[mode.value];
    if (val === void 0) {
      throw new Error(`Unknown blend mode: ${mode}`);
    }
    return val;
  };

  // src/Paint/Paint.ts
  var PaintJS = class _PaintJS extends HostObject {
    color = Float32Array.of(0, 0, 0, 1);
    paint = new Paint();
    constructor() {
      super("Paint");
    }
    getPaint() {
      return this.paint;
    }
    copy() {
      const { color: color2 } = this;
      const paint = new _PaintJS();
      paint.paint = this.paint.copy();
      if (color2 !== null) {
        paint.color = color2;
      }
      return paint;
    }
    getColor() {
      return this.color;
    }
    getStrokeCap() {
      return lineCap(this.paint.getStrokeCap());
    }
    getStrokeJoin() {
      return lineJoin(this.paint.getStrokeJoin());
    }
    getStrokeMiter() {
      return this.paint.getStrokeMiter();
    }
    getStrokeWidth() {
      return this.paint.getStrokeWidth();
    }
    setAlphaf(alpha) {
      this.color[3] = alpha;
      this.paint.setAlpha(alpha);
    }
    setAntiAlias(_aa) {
    }
    setBlendMode(mode) {
      this.paint.setBlendMode(nativeBlendMode(mode));
    }
    setColor(color2, _colorSpace) {
      this.color = color2 instanceof Float32Array ? color2 : Float32Array.from(color2);
      this.paint.setAlpha(this.color[3]);
      this.paint.setColor(
        `rgb(${Math.round(this.color[0] * 255)}, ${Math.round(
          this.color[1] * 255
        )}, ${Math.round(this.color[2] * 255)})`
      );
    }
    setColorComponents(r, g, b, a, _colorSpace) {
      this.setColor(Float32Array.of(r, g, b, a));
    }
    setColorFilter(filter) {
      if (!filter) {
        throw new Error("Filter cannot be null");
      }
      this.paint.addImageFilter(...filter.filters);
    }
    setColorInt(colorInt, _colorSpace) {
      let alpha = colorInt >>> 24 & 255;
      let red = colorInt >> 16 & 255;
      let green = colorInt >> 8 & 255;
      let blue = colorInt & 255;
      alpha /= 255;
      red /= 255;
      green /= 255;
      blue /= 255;
      this.setColor(Float32Array.of(red, green, blue, alpha));
    }
    setDither(_shouldDither) {
      throw new Error("Method not implemented.");
    }
    setImageFilter(filter) {
      if (!filter) {
        throw new Error("Filter cannot be null");
      }
      this.paint.addImageFilter(...filter.filters);
    }
    setMaskFilter(filter) {
      if (!filter) {
        throw new Error("Filter cannot be null");
      }
      this.paint.addImageFilter(...filter.filters);
    }
    setPathEffect(_effect) {
      throw new Error("Method not implemented.");
    }
    setShader(shader) {
      this.paint.setShader(shader ? shader.getShader() : shader);
    }
    setStrokeCap(cap) {
      this.paint.setStrokeCap(nativeLineCap(cap));
    }
    setStrokeJoin(join) {
      this.paint.setStrokeJoin(nativeLineJoin(join));
    }
    setStrokeMiter(limit) {
      this.paint.setStrokeMiter(limit);
    }
    setStrokeWidth(width) {
      this.paint.setStrokeWidth(width);
    }
    setStyle(style) {
      this.paint.setStrokeStyle(style === PaintStyle.Stroke);
    }
  };
  var lineCap = (cap) => {
    switch (cap) {
      case "butt":
        return StrokeCap.Butt;
      case "round":
        return StrokeCap.Round;
      case "square":
        return StrokeCap.Square;
      default:
        throw new Error(`Unknown line cap: ${cap}`);
    }
  };
  var nativeLineCap = (cap) => {
    switch (cap.value) {
      case 0:
        return "butt";
      case 1:
        return "round";
      case 2:
        return "square";
      default:
        throw new Error(`Unknown line cap: ${cap.value}`);
    }
  };
  var lineJoin = (join) => {
    switch (join) {
      case "miter":
        return StrokeJoin.Miter;
      case "round":
        return StrokeJoin.Round;
      case "bevel":
        return StrokeJoin.Bevel;
      default:
        throw new Error(`Unknown line cap: ${join}`);
    }
  };
  var nativeLineJoin = (join) => {
    switch (join.value) {
      case 0:
        return "miter";
      case 1:
        return "round";
      case 2:
        return "bevel";
      default:
        throw new Error(`Unknown line cap: ${join.value}`);
    }
  };

  // src/Path/Conic.ts
  var lerp2 = (a, b, t) => new DOMPoint(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));
  var midPoint = (a, b) => lerp2(a, b, 0.5);
  var splitCurve = (curve) => {
    const p01 = midPoint(curve.p0, curve.p1);
    const p12 = midPoint(curve.p1, curve.p2);
    const p0112 = midPoint(p01, p12);
    return [
      {
        p0: curve.p0,
        p1: p01,
        p2: p0112,
        w: curve.w
      },
      {
        p0: p0112,
        p1: p12,
        p2: curve.p2,
        w: curve.w
      }
    ];
  };
  var isCloseEnough = (curve, tolerance = 0.01) => {
    const dx = curve.p2.x - curve.p0.x;
    const dy = curve.p2.y - curve.p0.y;
    const d = Math.abs(
      dx * (curve.p0.y - curve.p1.y) - dy * (curve.p0.x - curve.p1.x)
    );
    return d < tolerance;
  };
  var toQuadratic = (curve) => new QuadraticPathComponent(curve.p0, curve.p1, curve.p2);
  var chopCurve = (curve, curves = []) => {
    if (isCloseEnough(curve)) {
      curves.push(toQuadratic(curve));
    } else {
      const [left, right] = splitCurve(curve);
      chopCurve(left, curves);
      chopCurve(right, curves);
    }
    return curves;
  };
  var ConvertConicToQuads = (p0, p1, p2, w) => {
    return chopCurve({ p0, p1, p2, w });
  };

  // src/Path/PathBuilder.ts
  var PathBuilder = class {
    constructor(path = new Path()) {
      this.path = path;
    }
    current = new DOMPoint(0, 0);
    subpathStart = null;
    getPath() {
      return this.path;
    }
    addPath(path) {
      path.enumerateComponents(
        (linear) => this.path.addLinearComponent(linear.p1, linear.p2),
        (quad) => this.path.addQuadraticComponent(quad.p1, quad.cp, quad.p2),
        (cubic) => this.path.addCubicComponent(cubic.p1, cubic.cp1, cubic.cp2, cubic.p2),
        (contour) => this.path.addContour(contour.closed)
      );
      return this;
    }
    conicTo(p1, p2, w) {
      const p0 = this.current;
      const quads = ConvertConicToQuads(p0, p1, p2, w);
      quads.forEach(
        (quad) => this.path.addQuadraticComponent(quad.p1, quad.cp, quad.p2)
      );
      return this;
    }
    addRoundedRect(rect, radii) {
      if (radii.topLeft.x === 0 && radii.topRight.x === 0 && radii.bottomRight.x === 0 && radii.bottomLeft.x === 0) {
        return this.addRect(rect);
      }
      this.current = new DOMPoint(rect.x + radii.topLeft.x, rect.y);
      this.moveTo(new DOMPoint(rect.x + radii.topLeft.x, rect.y));
      this.path.addLinearComponent(
        new DOMPoint(rect.x + radii.topLeft.x, rect.y),
        new DOMPoint(rect.x + rect.width - radii.topRight.x, rect.y)
      );
      this.addRoundedRectTopRight(rect, radii);
      this.path.addLinearComponent(
        new DOMPoint(rect.x + rect.width, rect.y + radii.topRight.y),
        new DOMPoint(
          rect.x + rect.width,
          rect.y + rect.height - radii.bottomRight.y
        )
      );
      this.addRoundedRectBottomRight(rect, radii);
      this.path.addLinearComponent(
        new DOMPoint(
          rect.x + rect.width - radii.bottomRight.x,
          rect.y + rect.height
        ),
        new DOMPoint(rect.x + radii.bottomLeft.x, rect.y + rect.height)
      );
      this.addRoundedRectBottomLeft(rect, radii);
      this.path.addLinearComponent(
        new DOMPoint(rect.x, rect.y + rect.height - radii.bottomLeft.y),
        new DOMPoint(rect.x, rect.y + radii.topLeft.y)
      );
      this.addRoundedRectTopLeft(rect, radii);
      this.close();
      return this;
    }
    addRoundedRectTopLeft(rect, radii) {
      const magicTopLeft = multiplyScalar(
        new DOMPoint(radii.topLeft.x, radii.topLeft.y),
        ARC_APPROXIMATION_MAGIC
      );
      this.path.addCubicComponent(
        vec(rect.x, rect.y + radii.topLeft.y),
        vec(rect.x, rect.y + radii.topLeft.y - magicTopLeft.y),
        vec(rect.x + radii.topLeft.x - magicTopLeft.x, rect.y),
        vec(rect.x + radii.topLeft.x, rect.y)
      );
      return this;
    }
    addRoundedRectTopRight(rect, radii) {
      const magicTopRight = multiplyScalar(
        new DOMPoint(radii.topRight.x, radii.topRight.y),
        ARC_APPROXIMATION_MAGIC
      );
      this.path.addCubicComponent(
        new DOMPoint(rect.x + rect.width - radii.topRight.x, rect.y),
        new DOMPoint(
          rect.x + rect.width - radii.topRight.x + magicTopRight.x,
          rect.y
        ),
        new DOMPoint(
          rect.x + rect.width,
          rect.y + radii.topRight.y - magicTopRight.y
        ),
        new DOMPoint(rect.x + rect.width, rect.y + radii.topRight.y)
      );
      return this;
    }
    addRoundedRectBottomRight(rect, radii) {
      const magicBottomRight = multiplyScalar(
        new DOMPoint(radii.bottomRight.x, radii.bottomRight.y),
        ARC_APPROXIMATION_MAGIC
      );
      this.path.addCubicComponent(
        vec(rect.x + rect.width, rect.y + rect.height - radii.bottomRight.y),
        vec(
          rect.x + rect.width,
          rect.y + rect.height - radii.bottomRight.y + magicBottomRight.y
        ),
        vec(
          rect.x + rect.width - radii.bottomRight.x + magicBottomRight.x,
          rect.y + rect.height
        ),
        vec(rect.x + rect.width - radii.bottomRight.x, rect.y + rect.height)
      );
      return this;
    }
    addRoundedRectBottomLeft(rect, radii) {
      const magicBottomLeft = multiplyScalar(
        new DOMPoint(radii.bottomLeft.x, radii.bottomLeft.y),
        ARC_APPROXIMATION_MAGIC
      );
      this.path.addCubicComponent(
        vec(rect.x + radii.bottomLeft.x, rect.y + rect.height),
        vec(
          rect.x + radii.bottomLeft.x - magicBottomLeft.x,
          rect.y + rect.height
        ),
        vec(
          rect.x,
          rect.y + rect.height - radii.bottomLeft.y + magicBottomLeft.y
        ),
        vec(rect.x, rect.y + rect.height - radii.bottomLeft.y)
      );
      return this;
    }
    addRect(rect) {
      this.current = vec(rect.x, rect.y);
      const tl = vec(rect.x, rect.y);
      const bl = vec(rect.x, rect.y + rect.height);
      const br = vec(rect.x + rect.width, rect.y + rect.height);
      const tr = vec(rect.x + rect.width, rect.y);
      this.moveTo(tl);
      this.path.addLinearComponent(tl, tr).addLinearComponent(tr, br).addLinearComponent(br, bl);
      this.close();
      return this;
    }
    addArc(bounds, start, sweep, useCenter = false) {
      if (sweep < 0) {
        start += sweep;
        sweep *= -1;
      }
      sweep = Math.min(TAU, sweep);
      start = start % TAU;
      const radius = vec(bounds.width / 2, bounds.height / 2);
      const center = vec(bounds.x + radius.x, bounds.y + radius.y);
      let p1Unit = vec(Math.cos(start), Math.sin(start));
      const m = plus(center, multiply(p1Unit, radius));
      if (useCenter) {
        this.moveTo(center);
        this.lineTo(m);
      } else {
        this.moveTo(m);
      }
      while (sweep > 0) {
        let p2Unit;
        let quadrantAngle;
        if (sweep < PI_OVER_2) {
          quadrantAngle = sweep;
          p2Unit = vec(
            Math.cos(start + quadrantAngle),
            Math.sin(start + quadrantAngle)
          );
        } else {
          quadrantAngle = PI_OVER_2;
          p2Unit = vec(-p1Unit.y, p1Unit.x);
        }
        const arcCpLengths = multiplyScalar(
          radius,
          quadrantAngle / PI_OVER_2 * ARC_APPROXIMATION_MAGIC
        );
        const p1 = plus(center, multiply(p1Unit, radius));
        const p2 = plus(center, multiply(p2Unit, radius));
        const cp1 = plus(p1, multiply(vec(-p1Unit.y, p1Unit.x), arcCpLengths));
        const cp2 = plus(p2, multiply(vec(p2Unit.y, -p2Unit.x), arcCpLengths));
        this.path.addCubicComponent(p1, cp1, cp2, p2);
        this.current = p2;
        start += quadrantAngle;
        sweep -= quadrantAngle;
        p1Unit = p2Unit;
      }
      if (useCenter) {
        this.close();
      }
      return this;
    }
    addOval(container) {
      const r = vec(container.width * 0.5, container.height * 0.5);
      const c = vec(container.x + r.x, container.y + r.y);
      const m = vec(ARC_APPROXIMATION_MAGIC * r.x, ARC_APPROXIMATION_MAGIC * r.y);
      this.moveTo(vec(c.x, c.y - r.y));
      this.path.addCubicComponent(
        vec(c.x, c.y - r.y),
        // p1
        vec(c.x + m.x, c.y - r.y),
        // cp1
        vec(c.x + r.x, c.y - m.y),
        // cp2
        vec(c.x + r.x, c.y)
        // p2
      );
      this.path.addCubicComponent(
        vec(c.x + r.x, c.y),
        // p1
        vec(c.x + r.x, c.y + m.y),
        // cp1
        vec(c.x + m.x, c.y + r.y),
        // cp2
        vec(c.x, c.y + r.y)
        // p2
      );
      this.path.addCubicComponent(
        vec(c.x, c.y + r.y),
        // p1
        vec(c.x - m.x, c.y + r.y),
        // cp1
        vec(c.x - r.x, c.y + m.y),
        // cp2
        vec(c.x - r.x, c.y)
        // p2
      );
      this.path.addCubicComponent(
        vec(c.x - r.x, c.y),
        // p1
        vec(c.x - r.x, c.y - m.y),
        // cp1
        vec(c.x - m.x, c.y - r.y),
        // cp2
        vec(c.x, c.y - r.y)
        // p2
      );
      this.close();
      return this;
    }
    cubicCurveTo(controlPoint1, controlPoint2, point, relative = false) {
      controlPoint1 = relative ? plus(this.current, controlPoint1) : controlPoint1;
      controlPoint2 = relative ? plus(this.current, controlPoint2) : controlPoint2;
      point = relative ? plus(this.current, point) : point;
      this.path.addCubicComponent(
        this.current,
        controlPoint1,
        controlPoint2,
        point
      );
      this.current = point;
      return this;
    }
    quadraticCurveTo(controlPoint, point, relative = false) {
      point = relative ? plus(this.current, point) : point;
      controlPoint = relative ? plus(this.current, controlPoint) : controlPoint;
      this.path.addQuadraticComponent(this.current, controlPoint, point);
      this.current = point;
      return this;
    }
    moveTo(p, relative = false) {
      this.current = relative ? plus(this.current, p) : p;
      this.subpathStart = this.current;
      this.path.addContour();
      return this;
    }
    lineTo(p, relative = false) {
      const point = relative ? plus(this.current, p) : p;
      this.path.addLinearComponent(this.current, point);
      this.current = point;
      return this;
    }
    close() {
      if (this.subpathStart) {
        this.lineTo(this.subpathStart);
        this.path.closeContour();
        this.path.addContour();
      }
      return this;
    }
    getLastPoint() {
      return this.current;
    }
  };

  // src/Path/SVG/Arc.ts
  var TAU2 = Math.PI * 2;
  var unitVectorAngle = (ux, uy, vx, vy) => {
    const sign = ux * vy - uy * vx < 0 ? -1 : 1;
    let dot2 = ux * vx + uy * vy;
    if (dot2 > 1) {
      dot2 = 1;
    }
    if (dot2 < -1) {
      dot2 = -1;
    }
    return sign * Math.acos(dot2);
  };
  var getArcCenter = (x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi) => {
    const x1p = cos_phi * (x1 - x2) / 2 + sin_phi * (y1 - y2) / 2;
    const y1p = -sin_phi * (x1 - x2) / 2 + cos_phi * (y1 - y2) / 2;
    const rx_sq = rx * rx;
    const ry_sq = ry * ry;
    const x1p_sq = x1p * x1p;
    const y1p_sq = y1p * y1p;
    let radicant = rx_sq * ry_sq - rx_sq * y1p_sq - ry_sq * x1p_sq;
    if (radicant < 0) {
      radicant = 0;
    }
    radicant /= rx_sq * y1p_sq + ry_sq * x1p_sq;
    radicant = Math.sqrt(radicant) * (fa === fs ? -1 : 1);
    const cxp = radicant * rx / ry * y1p;
    const cyp = radicant * -ry / rx * x1p;
    const cx = cos_phi * cxp - sin_phi * cyp + (x1 + x2) / 2;
    const cy = sin_phi * cxp + cos_phi * cyp + (y1 + y2) / 2;
    const v1x = (x1p - cxp) / rx;
    const v1y = (y1p - cyp) / ry;
    const v2x = (-x1p - cxp) / rx;
    const v2y = (-y1p - cyp) / ry;
    const theta1 = unitVectorAngle(1, 0, v1x, v1y);
    let delta_theta = unitVectorAngle(v1x, v1y, v2x, v2y);
    if (fs === 0 && delta_theta > 0) {
      delta_theta -= TAU2;
    }
    if (fs === 1 && delta_theta < 0) {
      delta_theta += TAU2;
    }
    return [cx, cy, theta1, delta_theta];
  };
  var approximate_unit_arc = (theta1, delta_theta) => {
    const alpha = 4 / 3 * Math.tan(delta_theta / 4);
    const x1 = Math.cos(theta1);
    const y1 = Math.sin(theta1);
    const x2 = Math.cos(theta1 + delta_theta);
    const y2 = Math.sin(theta1 + delta_theta);
    return [
      x1,
      y1,
      x1 - y1 * alpha,
      y1 + x1 * alpha,
      x2 + y2 * alpha,
      y2 - x2 * alpha,
      x2,
      y2
    ];
  };
  var a2c = (x1, y1, x2, y2, fa, fs, rx, ry, phi) => {
    const sin_phi = Math.sin(phi * TAU2 / 360);
    const cos_phi = Math.cos(phi * TAU2 / 360);
    const x1p = cos_phi * (x1 - x2) / 2 + sin_phi * (y1 - y2) / 2;
    const y1p = -sin_phi * (x1 - x2) / 2 + cos_phi * (y1 - y2) / 2;
    if (x1p === 0 && y1p === 0) {
      return [];
    }
    if (rx === 0 || ry === 0) {
      return [];
    }
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    const lambda = x1p * x1p / (rx * rx) + y1p * y1p / (ry * ry);
    if (lambda > 1) {
      rx *= Math.sqrt(lambda);
      ry *= Math.sqrt(lambda);
    }
    const cc = getArcCenter(
      x1,
      y1,
      x2,
      y2,
      fa,
      fs,
      rx,
      ry,
      sin_phi,
      cos_phi
    );
    const result = [];
    let theta1 = cc[2];
    let delta_theta = cc[3];
    const segments = Math.max(
      Math.ceil(Math.abs(delta_theta) / (TAU2 / 4)),
      1
    );
    delta_theta /= segments;
    for (let i = 0; i < segments; i++) {
      result.push(approximate_unit_arc(theta1, delta_theta));
      theta1 += delta_theta;
    }
    return result.map((curve) => {
      for (let i = 0; i < curve.length; i += 2) {
        let x = curve[i + 0];
        let y = curve[i + 1];
        x *= rx;
        y *= ry;
        const xp = cos_phi * x - sin_phi * y;
        const yp = sin_phi * x + cos_phi * y;
        curve[i + 0] = xp + cc[0];
        curve[i + 1] = yp + cc[1];
      }
      return curve;
    });
  };

  // src/Path/SVG/SVGParser.ts
  var length = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
  var stackCmd = (d, path, cmd, params, size) => {
    while (params.length > 0) {
      const args = params.splice(0, size);
      if (args.length < size) {
        throw new Error(`malformed path data: ${d}`);
      }
      const lCmd = cmd.toLowerCase();
      const rel = lCmd === cmd;
      const lastPoint = path.getLastPoint();
      const dx = rel ? lastPoint.x : 0;
      const dy = rel ? lastPoint.y : 0;
      const delta = vec(dx, dy);
      if (lCmd === "m") {
        path.moveTo(vec(args[0], args[1]), rel);
      } else if (lCmd === "c") {
        path.cubicCurveTo(
          vec(args[0], args[1]),
          vec(args[2], args[3]),
          vec(args[4], args[5]),
          rel
        );
      } else if (lCmd === "q") {
        path.quadraticCurveTo(vec(args[0], args[1]), vec(args[2], args[3]), rel);
      } else if (lCmd === "l") {
        path.lineTo(vec(args[0], args[1]), rel);
      } else if (lCmd === "h") {
        path.lineTo(vec(dx + args[0], path.getLastPoint().y));
      } else if (lCmd === "v") {
        path.lineTo(vec(path.getLastPoint().x, dy + args[0]));
      } else if (lCmd === "s") {
        const lastComp = path.getPath().getLastComponent();
        const cp2 = lastComp instanceof CubicPathComponent ? lastComp.cp2 : lastPoint;
        path.cubicCurveTo(
          cp2,
          plus(delta, vec(args[0], args[1])),
          plus(delta, vec(args[2], args[3]))
        );
      } else if (lCmd === "t") {
        const lastComp = path.getPath().getLastComponent();
        const cp = lastComp instanceof QuadraticPathComponent ? lastComp.cp : lastPoint;
        path.quadraticCurveTo(cp, plus(delta, vec(args[2], args[3])));
      } else if (lCmd === "a") {
        const curves = a2c(
          lastPoint.x,
          lastPoint.y,
          dx + args[5],
          dy + args[6],
          args[3],
          args[4],
          args[0],
          args[1],
          args[2]
        );
        for (const curve of curves) {
          path.cubicCurveTo(
            vec(curve[2], curve[3]),
            vec(curve[4], curve[5]),
            vec(curve[6], curve[7])
          );
        }
      }
    }
  };
  var parseSVG = (d) => {
    const path = new PathBuilder();
    const segment = /([astvzqmhlc])([^astvzqmhlc]*)/gi;
    const number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/gi;
    let match;
    while ((match = segment.exec(d)) !== null) {
      const command = match[1];
      const relative = command.toLowerCase() === command;
      const params = [];
      let numMatch;
      while ((numMatch = number.exec(match[2])) !== null) {
        params.push(parseFloat(numMatch[0]));
      }
      const cmdSize = length[command.toLowerCase()];
      if ((command === "m" || command === "M") && params.length > cmdSize) {
        const args = params.splice(0, cmdSize);
        if (args.length < cmdSize) {
          throw new Error(`malformed path data: ${d}`);
        }
        path.moveTo(vec(args[0], args[1]), relative);
        const lineTo = command === "m" ? "l" : "L";
        stackCmd(d, path, lineTo, params, cmdSize);
      } else if (command === "z" || command === "Z") {
        path.close();
      } else {
        stackCmd(d, path, command, params, cmdSize);
      }
    }
    return path;
  };

  // src/Path/PathEffects/TrimPathEffect.ts
  var TrimPathEffect = class {
    constructor(start, end, _complement) {
      this.start = start;
      this.end = end;
    }
    filterPath(path) {
      const trimmedPath = new Path();
      const totalLength = path.length();
      const startT = saturate(this.start);
      const stopT = saturate(this.end);
      const start = startT * totalLength;
      const stop = stopT * totalLength;
      if (start >= stop) {
        return trimmedPath;
      }
      let offset = 0;
      path.contours.forEach((contour) => {
        const contourLength = contour.length();
        const nextOffset = offset + contourLength;
        if (nextOffset <= start || offset >= stop) {
          offset = nextOffset;
          return;
        }
        const l0 = Math.max(0, start - offset / contourLength);
        const l1 = Math.min(contourLength, stop - offset / contourLength);
        const partialContour = contour.getSegment(l0, l1);
        trimmedPath.contours.push(partialContour);
        offset = nextOffset;
      });
      return trimmedPath;
    }
  };

  // src/Path/PathEffects/DashPathEffect.ts
  var DashPathEffect = class {
    constructor(on, off, phase) {
      this.on = on;
      this.off = off;
      this.phase = phase;
    }
    filterPath(path) {
      const dashedPath = new Path();
      const dashCycleLength = this.on + this.off;
      path.contours.forEach((contour) => {
        const contourLength = contour.length();
        let currentPos = this.phase % dashCycleLength - dashCycleLength;
        while (currentPos < contourLength) {
          const dashStart = currentPos + this.off;
          let dashEnd = dashStart + this.on;
          if (dashStart < contourLength) {
            dashEnd = Math.min(dashEnd, contourLength);
            const dashSegment = contour.getSegment(dashStart, dashEnd);
            dashedPath.contours.push(dashSegment);
          }
          currentPos += dashCycleLength;
        }
      });
      return dashedPath;
    }
  };

  // src/Path/PathJS.ts
  var PathJS = class _PathJS extends HostObject {
    path;
    fillType = "nonzero";
    constructor(path) {
      super("Path");
      this.path = path ?? new PathBuilder();
    }
    swap(path) {
      this.path = new PathBuilder(path);
      return this;
    }
    getPath() {
      return this.path.getPath();
    }
    addArc(inputBounds, startAngle, sweepAngle) {
      this.path.addArc(
        rectToXYWH(inputBounds),
        toRad(startAngle),
        toRad(sweepAngle),
        false
      );
      return this;
    }
    addCircle(x, y, r, isCCW) {
      this.addOval([x - r, y - r, x + r, y + r], isCCW);
      return this;
    }
    addOval(oval, _isCCW, _startIndex) {
      this.path.addOval(rectToXYWH(oval));
      return this;
    }
    addPath(newPath, _matrix) {
      this.path.addPath(newPath.path.getPath());
      return this;
    }
    addPoly(input, close) {
      const points = normalizeArray(input);
      points.forEach((x, index) => {
        const y = points[index + 1];
        if (index === 0) {
          this.path.moveTo(vec(x, y));
        }
        if (index % 2 === 0) {
          this.path.lineTo(vec(x, y));
        }
      });
      if (close) {
        this.path.close();
      }
      return this;
    }
    addRect(input, _isCCW) {
      this.path.addRect(rectToXYWH(input));
      return this;
    }
    addRRect(input, _isCCW) {
      const rrect = rrectToXYWH(input);
      this.path.addRoundedRect(rrect, rrect.radii);
      return this;
    }
    addVerbsPointsWeights(_verbs, _points, _weights) {
      throw new Error("Method not implemented.");
    }
    arc(_x, _y, _r, _startAngle, _endAngle, _isCCW) {
      throw new Error("Method not implemented.");
    }
    arcToOval(_oval, _startAngle, _endAngle, _forceMoveTo) {
      throw new Error("Method not implemented.");
    }
    arcToRotated(_rx, _ry, _xAxisRotate, _useSmallArc, _isCCW, _x, _y) {
      throw new Error("Method not implemented.");
    }
    arcToTangent(_x1, _y1, _x2, _y2, _radius) {
      throw new Error("Method not implemented.");
    }
    close() {
      this.path.close();
      return this;
    }
    computeTightBounds(outputArray) {
      const result = outputArray ?? new Float32Array(4);
      this.path.getPath().computeTightBounds(result);
      return result;
    }
    conicTo(x1, y1, x2, y2, w) {
      this.path.conicTo(vec(x1, y1), vec(x2, y2), w);
      return this;
    }
    contains(x, y) {
      const offscreen2 = new OffscreenCanvas(1, 1);
      const ctx = offscreen2.getContext("2d");
      const path = this.getPath2D();
      const result = ctx.isPointInPath(path, x, y);
      return result;
    }
    copy() {
      return _PathJS.MakeFromCmds(this.toCmds());
    }
    countPoints() {
      return this.path.getPath().getPoints().length;
    }
    cubicTo(cpx1, cpy1, cpx2, cpy2, x, y, relative = false) {
      this.path.cubicCurveTo(
        vec(cpx1, cpy1),
        vec(cpx2, cpy2),
        vec(x, y),
        relative
      );
      return this;
    }
    dash(on, off, phase) {
      const pe = new DashPathEffect(on, off, phase);
      this.swap(pe.filterPath(this.path.getPath()));
      return true;
    }
    equals(_other) {
      throw new Error("Method not implemented.");
    }
    getBounds(outputArray) {
      const result = outputArray ?? new Float32Array(4);
      calculateBounds(this.path.getPath().getPoints(), result);
      return result;
    }
    getNativeFillType() {
      return this.fillType;
    }
    getFillType() {
      if (this.fillType === "evenodd") {
        return FillType.EvenOdd;
      }
      return FillType.Winding;
    }
    getPoint(index, outputArray) {
      const result = outputArray ?? new Float32Array(2);
      const point = this.path.getPath().getPoints()[index];
      result[0] = point.x;
      result[1] = point.y;
      return result;
    }
    isEmpty() {
      throw new Error("Method not implemented.");
    }
    isVolatile() {
      throw new Error("Method not implemented.");
    }
    lineTo(x, y, relative = false) {
      this.path.lineTo(vec(x, y), relative);
      return this;
    }
    makeAsWinding() {
      throw new Error("Method not implemented.");
    }
    moveTo(x, y, relative = false) {
      this.path.moveTo(vec(x, y), relative);
      return this;
    }
    offset(dx, dy) {
      return this.transform([1, 0, dx, 0, 1, dy, 0, 0, 1]);
    }
    op(_other, _op) {
      throw new Error("Method not implemented.");
    }
    quadTo(x1, y1, x2, y2, relative = false) {
      this.path.quadraticCurveTo(vec(x1, y1), vec(x2, y2), relative);
      return this;
    }
    rArcTo(_rx, _ry, _xAxisRotate, _useSmallArc, _isCCW, _dx, _dy) {
      throw new Error("Method not implemented.");
    }
    rConicTo(_dx1, _dy1, _dx2, _dy2, _w) {
      throw new Error("Method not implemented.");
    }
    rCubicTo(cpx1, cpy1, cpx2, cpy2, x, y) {
      this.cubicTo(cpx1, cpy1, cpx2, cpy2, x, y, true);
      return this;
    }
    reset() {
      this.path = new PathBuilder();
      this.fillType = "nonzero";
    }
    rewind() {
      this.reset();
    }
    rLineTo(x, y) {
      this.path.lineTo(vec(x, y), true);
      return this;
    }
    rMoveTo(x, y) {
      this.path.moveTo(vec(x, y), true);
      return this;
    }
    rQuadTo(x1, y1, x2, y2) {
      this.path.quadraticCurveTo(vec(x1, y1), vec(x2, y2), true);
      return this;
    }
    setFillType(fill) {
      if (fill.value === 1 /* EvenOdd */) {
        this.fillType = "evenodd";
      } else {
        this.fillType = "nonzero";
      }
    }
    setIsVolatile(_volatile) {
    }
    simplify() {
      throw new Error("Method not implemented.");
    }
    stroke(_opts) {
      throw new Error("Method not implemented.");
    }
    toCmds() {
      return Float32Array.of(...this.path.getPath().toCmds());
    }
    toSVGString() {
      return this.path.getPath().toSVGString();
    }
    transform(m3) {
      const path = new PathBuilder();
      const cmds = this.toCmds();
      let i = 0;
      while (i < cmds.length) {
        const cmd = cmds[i++];
        if (cmd === 0 /* Move */) {
          const to = transformPoint(m3, cmds[i++], cmds[i++]);
          path.moveTo(to);
        } else if (cmd === 1 /* Line */) {
          const to = transformPoint(m3, cmds[i++], cmds[i++]);
          path.lineTo(to);
        } else if (cmd === 4 /* Cubic */) {
          const cp1 = transformPoint(m3, cmds[i++], cmds[i++]);
          const cp2 = transformPoint(m3, cmds[i++], cmds[i++]);
          const to = transformPoint(m3, cmds[i++], cmds[i++]);
          path.cubicCurveTo(cp1, cp2, to);
        } else if (cmd === 2 /* Quad */) {
          const cp = transformPoint(m3, cmds[i++], cmds[i++]);
          const to = transformPoint(m3, cmds[i++], cmds[i++]);
          path.quadraticCurveTo(cp, to);
        } else if (cmd === 5 /* Close */) {
          path.close();
        }
      }
      this.path = path;
      return this;
    }
    trim(startT, stopT, isComplement) {
      const pe = new TrimPathEffect(startT, stopT, isComplement);
      return this.swap(pe.filterPath(this.path.getPath()));
    }
    getPath2D() {
      const path = new Path2D();
      const cmds = this.toCmds();
      let i = 0;
      while (i < cmds.length) {
        const cmd = cmds[i++];
        if (cmd === 0 /* Move */) {
          path.moveTo(cmds[i++], cmds[i++]);
        } else if (cmd === 1 /* Line */) {
          path.lineTo(cmds[i++], cmds[i++]);
        } else if (cmd === 4 /* Cubic */) {
          path.bezierCurveTo(
            cmds[i++],
            cmds[i++],
            cmds[i++],
            cmds[i++],
            cmds[i++],
            cmds[i++]
          );
        } else if (cmd === 2 /* Quad */) {
          path.quadraticCurveTo(cmds[i++], cmds[i++], cmds[i++], cmds[i++]);
        } else if (cmd === 5 /* Close */) {
          i++;
          path.closePath();
        }
      }
      return path;
    }
    static CanInterpolate(path1, path2) {
      const p1 = path1.getPath();
      const p2 = path2.getPath();
      let result = true;
      p1.contours.forEach((contour, index) => {
        const otherContour = p2.contours[index];
        if (contour.components.length !== otherContour.components.length) {
          result = false;
          return;
        }
        contour.components.forEach((component, j) => {
          const otherComponent = otherContour.components[j];
          if (component.type !== otherComponent.type) {
            result = false;
            return;
          }
        });
      });
      return result;
    }
    static MakeFromCmds(input) {
      const cmds = normalizeArray(input);
      const path = new PathBuilder();
      let i = 0;
      while (i < cmds.length) {
        const cmd = cmds[i++];
        if (cmd === 0 /* Move */) {
          path.moveTo(vec(cmds[i++], cmds[i++]));
        } else if (cmd === 1 /* Line */) {
          path.lineTo(vec(cmds[i++], cmds[i++]));
        } else if (cmd === 4 /* Cubic */) {
          path.cubicCurveTo(
            vec(cmds[i++], cmds[i++]),
            vec(cmds[i++], cmds[i++]),
            vec(cmds[i++], cmds[i++])
          );
        } else if (cmd === 2 /* Quad */) {
          path.quadraticCurveTo(
            vec(cmds[i++], cmds[i++]),
            vec(cmds[i++], cmds[i++])
          );
        } else if (cmd === 5 /* Close */) {
          i++;
          path.close();
        }
      }
      return new _PathJS(path);
    }
    static MakeFromOp(_one, _two, _op) {
      throw new Error("Function not implemented.");
    }
    static MakeFromPathInterpolation(start, end, t) {
      const cmd1 = start.toCmds();
      const cmd2 = end.toCmds();
      const cmd3 = cmd1.map((cmd, index) => {
        const c = cmd2[index];
        if (c === cmd) {
          return cmd;
        }
        return (1 - t) * c + t * cmd;
      });
      return _PathJS.MakeFromCmds(cmd3);
    }
    static MakeFromSVGString(d) {
      try {
        return new _PathJS(parseSVG(d));
      } catch (e) {
        return null;
      }
    }
    static MakeFromVerbsPointsWeights(_verbs, _points, _weights) {
      throw new Error("Function not implemented.");
    }
  };
  var calculateBounds = (points, outputArray) => {
    if (!points.length) {
      throw new Error("No points provided");
    }
    let left = Infinity;
    let top = Infinity;
    let right = -Infinity;
    let bottom = -Infinity;
    for (const point of points) {
      const x = point.x;
      const y = point.y;
      if (x < left) {
        left = x;
      }
      if (x > right) {
        right = x;
      }
      if (y < top) {
        top = y;
      }
      if (y > bottom) {
        bottom = y;
      }
    }
    outputArray[0] = left;
    outputArray[1] = top;
    outputArray[2] = right;
    outputArray[3] = bottom;
  };

  // src/Canvas/Canvas.ts
  var CanvasJS = class extends HostObject {
    ctx;
    width;
    height;
    saveCount = 0;
    constructor(ctx) {
      super("Canvas");
      this.width = ctx.canvas.width;
      this.height = ctx.canvas.height;
      this.ctx = new Canvas(ctx);
    }
    clear(color2) {
      const paint = new PaintJS();
      paint.setColor(color2);
      paint.setBlendMode(BlendMode.Clear);
      this.drawPaint(paint);
    }
    clipPath(path, _op, _doAntiAlias) {
      this._clip(path.getPath());
    }
    clipRect(rect, _op, _doAntiAlias) {
      const { x, y, width, height } = rectToXYWH(rect);
      const path = new Path();
      path.moveTo(new DOMPoint(x, y));
      path.lineTo(new DOMPoint(x + width, y));
      path.lineTo(new DOMPoint(x + width, y + height));
      path.lineTo(new DOMPoint(x, y + height));
      path.close();
      this._clip(path);
    }
    clipRRect(rrect, _op, _doAntiAlias) {
      const { x, y, width, height, radii } = rrectToXYWH(rrect);
      const path = new PathJS();
      path.addRRect([
        x,
        y,
        width,
        height,
        radii.topLeft.x,
        radii.topLeft.y,
        radii.topRight.x,
        radii.topRight.y,
        radii.bottomRight.x,
        radii.bottomRight.y,
        radii.bottomLeft.x,
        radii.bottomLeft.y
      ]);
      this._clip(path.getPath());
    }
    _clip(path) {
      this.ctx.clip(path);
    }
    concat(m) {
      const m3 = nativeMatrix(m);
      this.ctx.concat(m3);
    }
    drawArc(oval, startAngle, sweepAngle, _useCenter, paint) {
      const path = new PathJS();
      const rct = rectToXYWH(oval);
      path.arc(
        rct.width / 2,
        rct.height / 2,
        rct.width / 2,
        startAngle,
        sweepAngle
      );
      this.ctx.drawPath(path.getPath(), paint.getPaint());
    }
    drawAtlas(_atlas, _srcRects, _dstXforms, _paint, _blendMode, _colors, _sampling) {
      throw new Error("Method not implemented.");
    }
    drawCircle(cx, cy, radius, paint) {
      const path = new PathJS();
      path.addCircle(cx, cy, radius);
      this.ctx.drawPath(path.getPath(), paint.getPaint());
    }
    drawColor(color2, blendMode) {
      const paint = new PaintJS();
      paint.setColor(color2);
      if (blendMode) {
        paint.setBlendMode(blendMode);
      }
      this.drawPaint(paint);
    }
    drawColorComponents(r, g, b, a, blendMode) {
      this.drawColor(Float32Array.of(r, g, b, a), blendMode);
    }
    drawColorInt(color2, blendMode) {
      this.drawColor(intAsColor(color2), blendMode);
    }
    drawDRRect(outerInput, innerInput, paint) {
      this.ctx.draw(
        new DrawableDRRect(rrectToPath2D(outerInput), rrectToPath2D(innerInput)),
        paint.getPaint()
      );
    }
    drawGlyphs(_glyphs, _positions, _x, _y, _font, _paint) {
      throw new Error("Method not implemented.");
    }
    drawImage(img, x, y, _paint) {
      const paint = _paint || new PaintJS();
      this.ctx.draw(new DrawableImage(img.getImage(), x, y), paint.getPaint());
    }
    drawImageCubic(_img, _left, _top, _B, _C, _paint) {
      throw new Error("Method not implemented.");
    }
    drawImageOptions(_img, _left, _top, _fm, _mm, _paint) {
      throw new Error("Method not implemented.");
    }
    drawImageNine(_img, _center, _dest, _filter, _paint) {
      throw new Error("Method not implemented.");
    }
    drawImageRect(img, _src, _dest, paint, _fastSample) {
      const src = rectToXYWH(_src);
      const dest = rectToXYWH(_dest);
      this.ctx.draw(
        new DrawableImageRect(
          img.getImage(),
          src.x,
          src.y,
          src.width,
          src.height,
          dest.x,
          dest.y,
          dest.width,
          dest.height
        ),
        paint.getPaint()
      );
    }
    drawImageRectCubic(_img, _src, _dest, _B, _C, _paint) {
      throw new Error("Method not implemented.");
    }
    drawImageRectOptions(_img, _src, _dest, _fm, _mm, _paint) {
      throw new Error("Method not implemented.");
    }
    drawLine(x0, y0, x1, y1, paint) {
      const path = new PathJS();
      path.moveTo(x0, y0);
      path.lineTo(x1, y1);
      this.ctx.drawPath(path.getPath(), paint.getPaint());
    }
    drawOval(_oval, _paint) {
      throw new Error("Method not implemented.");
    }
    drawPaint(paint) {
      this.ctx.draw(new DrawableFill(this.width, this.height), paint.getPaint());
    }
    drawParagraph(_p, _x, _y) {
      throw new Error("Method not implemented.");
    }
    drawPath(path, paint) {
      this.ctx.drawPath(path.getPath(), paint.getPaint());
    }
    drawPatch(_cubics, _colors, _texs, _mode, _paint) {
      throw new Error("Method not implemented.");
    }
    drawPicture(pic) {
      pic.canvas.replay(this);
    }
    drawPoints(_mode, _points, _paint) {
      throw new Error("Method not implemented.");
    }
    drawRect(rect, paint) {
      const path = new PathJS();
      path.addRect(rect);
      this.ctx.drawPath(path.getPath(), paint.getPaint());
    }
    drawRect4f(left, top, right, bottom, paint) {
      this.drawRect(Float32Array.of(left, top, right, bottom), paint);
    }
    drawRRect(rrect, paint) {
      const path = new PathJS();
      path.addRRect(rrect);
      this.ctx.drawPath(path.getPath(), paint.getPaint());
    }
    drawShadow(_path, _zPlaneParams, _lightPos, _lightRadius, _ambientColor, _spotColor, _flags) {
      throw new Error("Method not implemented.");
    }
    drawText(str, x, y, paint, font) {
      this.ctx.draw(
        new DrawableText(str, x, y, font.fontStyle()),
        paint.getPaint()
      );
    }
    drawTextBlob(_blob, _x, _y, _paint) {
      throw new Error("Method not implemented.");
    }
    drawVertices(_verts, _mode, _paint) {
      throw new Error("Method not implemented.");
    }
    getDeviceClipBounds(_output) {
      throw new Error("Method not implemented.");
    }
    getLocalToDevice() {
      const m = this.ctx.getMatrix();
      return Float32Array.of(
        m.m11,
        m.m21,
        m.m31,
        m.m41,
        m.m12,
        m.m22,
        m.m32,
        m.m42,
        m.m13,
        m.m23,
        m.m33,
        m.m43,
        m.m14,
        m.m24,
        m.m34,
        m.m44
      );
    }
    getSaveCount() {
      return this.saveCount;
    }
    getTotalMatrix() {
      const matrix = this.ctx.getMatrix();
      return [
        matrix.m11,
        matrix.m21,
        matrix.m41,
        matrix.m12,
        matrix.m22,
        matrix.m42,
        matrix.m14,
        matrix.m24,
        matrix.m44
      ];
    }
    makeSurface(_info) {
      throw new Error("Method not implemented.");
    }
    readPixels(_srcX, _srcY, _imageInfo, _dest, _bytesPerRow) {
      throw new Error("Method not implemented.");
    }
    restore() {
      this.ctx.restore();
    }
    restoreToCount(saveCount) {
      for (let i = 1; i <= saveCount; i++) {
        this.restore();
      }
    }
    rotate(rot, rx, ry) {
      const m = new DOMMatrix().translate(rx, ry).rotate(rot).translate(-rx, -ry);
      this.concat(m);
    }
    save() {
      this.ctx.save();
      return ++this.saveCount;
    }
    saveLayer(_paint, _bounds, imageFilter, _flags) {
      this.ctx.save(
        imageFilter ? new ImageFilter(imageFilter.filters) : void 0
      );
      return ++this.saveCount;
    }
    scale(sx, sy) {
      const m = new DOMMatrix().scale(sx, sy);
      this.concat(m);
    }
    skew(sx, sy) {
      const rSx = Math.tan(sx);
      const rSy = Math.tan(sy);
      const m = new DOMMatrix([1, rSy, rSx, 1, 0, 0]);
      this.concat(m);
    }
    translate(x, y) {
      this.concat(new DOMMatrix().translate(x, y));
    }
    writePixels(_pixels, _width, _height, _destX, _destY, _alphaType, _colorType, _colorSpace) {
      throw new Error("Method not implemented.");
    }
  };

  // src/Shader/Shader.ts
  var ShaderJS = class extends HostObject {
    constructor(_shader) {
      super("Shader");
      this._shader = _shader;
    }
    getShader() {
      return this._shader;
    }
  };

  // src/Shader/ImageShader.ts
  var ImageShader2 = class extends ShaderJS {
    constructor(image, localMatrix) {
      super(
        new ImageShader(
          image,
          localMatrix ? nativeMatrix(localMatrix) : void 0
        )
      );
    }
  };

  // src/Image.ts
  var dataURLToByteArray = (dataUrl) => {
    const split = dataUrl.split(",");
    if (split.length !== 2) {
      throw new Error("Invalid data URL.");
    }
    const decoded = atob(split[1]);
    const byteArray = new Uint8Array(decoded.length);
    for (let i = 0; i < decoded.length; i++) {
      byteArray[i] = decoded.charCodeAt(i);
    }
    return byteArray;
  };
  var ImageJS = class _ImageJS extends HostObject {
    image;
    constructor(source) {
      super("Image");
      if (source instanceof HTMLCanvasElement) {
        this.image = source;
      } else {
        const width = typeof source.width === "number" ? source.width : source.width.animVal.value;
        const height = typeof source.height === "number" ? source.height : source.height.animVal.value;
        const ctx = createTexture(width, height);
        this.image = ctx.canvas;
        if (source instanceof ImageData) {
          ctx.putImageData(source, 0, 0);
        } else {
          ctx.drawImage(source, 0, 0);
        }
      }
    }
    getImage() {
      return this.image;
    }
    encodeToBytes(fmt, quality) {
      let mime = "image/png";
      if (fmt?.value === 3 /* JPEG */) {
        mime = "image/jpeg";
      } else if (fmt?.value === 6 /* WEBP */) {
        mime = "image/webp";
      }
      const dataUrl = this.image.toDataURL(mime, quality);
      return dataURLToByteArray(dataUrl);
    }
    getColorSpace() {
      throw new Error("Method not implemented.");
    }
    getImageInfo() {
      return {
        alphaType: { value: 2 },
        colorType: { value: 2 },
        height: this.image.height,
        width: this.image.width
      };
    }
    height() {
      return this.image.height;
    }
    makeCopyWithDefaultMipmaps() {
      return new _ImageJS(this.image);
    }
    makeShaderCubic(_tx, _ty, _B, _C, localMatrix) {
      return new ImageShader2(this.image, localMatrix);
    }
    makeShaderOptions(_tx, _ty, _fm, _mm, localMatrix) {
      return new ImageShader2(this.image, localMatrix);
    }
    readPixels(_srcX, _srcY, _imageInfo, _dest, _bytesPerRow) {
      throw new Error("Method not implemented.");
    }
    width() {
      return this.image.width;
    }
  };

  // src/Core/CanvasProxyHandler.ts
  var CanvasProxyHandler = class {
    commands = [];
    get(target, property) {
      const origProperty = target[property];
      if (typeof origProperty === "function") {
        return (...args) => {
          const cmd = `ctx.${String(property)}(${args.map((arg) => JSON.stringify(arg)).join(", ")});`;
          if (property === "save") {
            this.commands.push("<layer>");
          } else if (property === "restore") {
            this.commands.push("</layer>");
          } else {
            this.commands.push(cmd);
          }
          return origProperty.apply(target, args);
        };
      } else {
        return origProperty;
      }
    }
    set(target, property, value) {
      this.commands.push(`ctx.${String(property)} = ${JSON.stringify(value)};`);
      target[property] = value;
      return true;
    }
    flush() {
      console.log(`<drawing>${this.commands.join("\n")}</drawing>`);
    }
  };

  // src/Surface.ts
  var SurfaceJS = class extends IndexedHostObject {
    canvas;
    ctx;
    proxyHandler = null;
    constructor(ctx, debug = false) {
      super("Surface", "surface");
      if (debug) {
        this.proxyHandler = new CanvasProxyHandler();
        this.ctx = new Proxy(ctx, this.proxyHandler);
      } else {
        this.ctx = ctx;
      }
      this.canvas = new CanvasJS(this.ctx);
    }
    drawOnce(drawFrame) {
      this.requestAnimationFrame(drawFrame);
    }
    dispose() {
    }
    flush() {
      if (this.proxyHandler) {
        this.proxyHandler.flush();
      }
    }
    getCanvas() {
      return this.canvas;
    }
    height() {
      return this.ctx.canvas.height;
    }
    imageInfo() {
      throw new Error("Method not implemented.");
    }
    makeImageFromTexture(_tex, _info) {
      throw new Error("Method not implemented.");
    }
    makeImageFromTextureSource(_src, _info, _srcIsPremul) {
      throw new Error("Method not implemented.");
    }
    makeImageSnapshot(_bounds) {
      const bounds = _bounds ? rectToXYWH(_bounds) : {
        x: 0,
        y: 0,
        width: this.width(),
        height: this.height()
      };
      const data = this.ctx.getImageData(
        bounds.x,
        bounds.y,
        bounds.width,
        bounds.height
      );
      return new ImageJS(data);
    }
    makeSurface(_info) {
      throw new Error("Method not implemented.");
    }
    reportBackendTypeIsGPU() {
      return true;
    }
    requestAnimationFrame(drawFrame) {
      return requestAnimationFrame(() => {
        drawFrame(this.canvas);
      });
    }
    sampleCnt() {
      throw new Error("Method not implemented.");
    }
    updateTextureFromSource(_img, _src, _srcIsPremul) {
      throw new Error("Method not implemented.");
    }
    width() {
      return this.ctx.canvas.width;
    }
  };

  // src/Shader/ColorShader.ts
  var ColorShader2 = class extends ShaderJS {
    constructor(color2) {
      super(new ColorShader(color2));
    }
  };

  // src/Shader/BlendShader.ts
  var BlendShader2 = class extends ShaderJS {
    constructor(blendMode, child1, child2) {
      super(
        new BlendShader(
          nativeBlendMode(blendMode),
          child1.getShader(),
          child2.getShader()
        )
      );
    }
  };

  // src/Shader/Gradients/LinearGradient.ts
  var LinearGradient2 = class extends ShaderJS {
    constructor(start, end, colors, pos) {
      super(
        new LinearGradient(
          nativePoint(start),
          nativePoint(end),
          normalizeInputColorArray(colors).map((c) => nativeColor(c)),
          pos ?? void 0
        )
      );
    }
  };

  // src/Shader/Gradients/TwoPointConicalGradient.ts
  var TwoPointConicalGradient2 = class extends ShaderJS {
    constructor(c1, r1, c2, r2, colors, pos) {
      super(
        new TwoPointConicalGradient(
          nativePoint(c1),
          r1,
          nativePoint(c2),
          r2,
          normalizeInputColorArray(colors).map((c) => nativeColor(c)),
          pos ?? void 0
        )
      );
    }
  };

  // src/Shader/Gradients/SweepGradient.ts
  var SweepGradient2 = class extends ShaderJS {
    constructor(c, startAngle, colors, pos) {
      super(
        new SweepGradient(
          nativePoint(c),
          startAngle,
          normalizeInputColorArray(colors).map((cl) => nativeColor(cl)),
          pos ?? void 0
        )
      );
    }
  };

  // src/Shader/ShaderFactory.ts
  var ShaderFactory = {
    MakeBlend: function(mode, one, two) {
      return new BlendShader2(mode, one, two);
    },
    MakeColor: function(color2, _space) {
      return new ColorShader2(nativeColor(color2));
    },
    MakeFractalNoise: function(_baseFreqX, _baseFreqY, _octaves, _seed, _tileW, _tileH) {
      throw new Error("Not implemented");
    },
    MakeLinearGradient: function(start, end, colors, pos, _mode, _localMatrix, _flags, _colorSpace) {
      return new LinearGradient2(start, end, colors, pos);
    },
    MakeRadialGradient: function(center, radius, colors, pos, _mode, _localMatrix, _flags, _colorSpace) {
      return new TwoPointConicalGradient2(center, 0, center, radius, colors, pos);
    },
    MakeSweepGradient: function(cx, cy, colors, pos, _mode, _localMatrix, _flags, startAngle, _endAngle, _colorSpace) {
      return new SweepGradient2(
        Float32Array.of(cx, cy),
        startAngle ?? 0,
        colors,
        pos
      );
    },
    MakeTurbulence: function(_baseFreqX, _baseFreqY, _octaves, _seed, _tileW, _tileH) {
      throw new Error("Not implemented");
    },
    MakeTwoPointConicalGradient: function(start, startRadius, end, endRadius, colors, pos, _mode, _localMatrix, _flags, _colorSpace) {
      return new TwoPointConicalGradient2(
        start,
        startRadius,
        end,
        endRadius,
        colors,
        pos
      );
    }
  };

  // src/ImageFilter/ImageFilter.ts
  var NativeFilter = class extends IndexedHostObject {
    _filters = [];
    constructor(type) {
      super(type, "filter");
    }
    get filters() {
      return this._filters;
    }
  };
  var ImageFilterJS = class extends NativeFilter {
    constructor() {
      super("ImageFilter");
    }
  };

  // src/ImageFilter/BlurImageFilter.ts
  var BlurImageFilter2 = class extends ImageFilterJS {
    constructor(sigmaX, sigmaY, input = null) {
      super();
      this.sigmaX = sigmaX;
      this.sigmaY = sigmaY;
      this.input = input;
      const blur = makeBlur(sigmaX, sigmaY);
      this._filters.push(blur);
      if (input) {
        this._filters.push(...input.filters);
      }
    }
  };

  // src/ImageFilter/ComposeImageFilter.ts
  var ComposeImageFilter = class extends ImageFilterJS {
    constructor(outer, inner) {
      super();
      if (inner) {
        this._filters.push(...inner.filters);
      }
      if (outer) {
        this._filters.push(...outer.filters);
      }
    }
  };

  // src/ImageFilter/ImageFilterFactory.ts
  var ImageFilterFactory = {
    MakeBlend: function(_blend, _background, _foreground) {
      throw new Error("Function not implemented.");
    },
    MakeBlur: function(sigmaX, sigmaY, _mode, input) {
      return new BlurImageFilter2(sigmaX, sigmaY, input);
    },
    MakeColorFilter: function(cf, input) {
      return new ComposeImageFilter(cf, input);
    },
    MakeCompose: function(outer, inner) {
      return new ComposeImageFilter(outer, inner);
    },
    MakeDilate: function(_radiusX, _radiusY, _input) {
      throw new Error("Function not implemented.");
    },
    MakeDisplacementMap: function(_xChannel, _yChannel, _scale, _displacement, _color) {
      throw new Error("Function not implemented.");
    },
    MakeDropShadow: function(_dx, _dy, _sigmaX, _sigmaY, _color, _input) {
      throw new Error("Function not implemented.");
    },
    MakeDropShadowOnly: function(_dx, _dy, _sigmaX, _sigmaY, _color, _input) {
      throw new Error("Function not implemented.");
    },
    MakeErode: function(_radiusX, _radiusY, _input) {
      throw new Error("Function not implemented.");
    },
    MakeImage: function(_img, _sampling) {
      throw new Error("Function not implemented.");
    },
    MakeMatrixTransform: function(_matr, _sampling, _input) {
      throw new Error("Function not implemented.");
    },
    MakeOffset: function(_dx, _dy, _input) {
      throw new Error("Function not implemented.");
    },
    MakeShader: function(_shader) {
      throw new Error("Function not implemented.");
    }
  };

  // src/MaskFilter/MaskFilter.ts
  var MaskFilterJS = class extends NativeFilter {
    constructor() {
      super("MaskFilter");
    }
  };

  // src/MaskFilter/BlurMaskFilter.ts
  var BlurMaskFilter = class extends MaskFilterJS {
    constructor(style, sigma) {
      super();
      this.style = style;
      this.sigma = sigma;
      const blur = makeBlur(sigma, sigma);
      this._filters.push(blur);
      if (this.style === 1 /* Solid */) {
        this._filters.push(makeMerge([blur, SourceGraphic]));
      } else if (this.style === 2 /* Outer */) {
        this._filters.push(makeComposite(blur, SourceGraphic, "out"));
      } else if (this.style === 3 /* Inner */) {
        this._filters.push(makeComposite(blur, SourceGraphic, "in"));
      }
    }
  };

  // src/MaskFilter/MaskFilterFactory.ts
  var MaskFilterFactory = {
    MakeBlur: function(style, sigma, _respectCTM) {
      return new BlurMaskFilter(style.value, sigma);
    }
  };

  // src/EmulatedCanvas2D.ts
  var EmulatedCanvas2DJS = class {
    constructor(canvas) {
      this.canvas = canvas;
    }
    dispose() {
    }
    decodeImage(_bytes) {
      throw new Error("Method not implemented.");
    }
    getContext(_type) {
      return this.canvas.getContext("2d");
    }
    loadFont(_bytes, _descriptors) {
      throw new Error("Method not implemented.");
    }
    makePath2D(str) {
      return new Path2D(str);
    }
    toDataURL(codec, quality) {
      return this.canvas.toDataURL(codec, quality);
    }
  };

  // src/RuntimeEffect/RuntimeEffect.ts
  var RuntimeEffectJS = class extends HostObject {
    constructor(ctx) {
      super("RuntimeEffect");
      this.ctx = ctx;
      this.uniformMap = this.getUniforms().filter(
        (u) => u.type !== ctx.gl.SAMPLER_2D
      );
    }
    uniformMap;
    getUniforms() {
      const { gl, program } = this.ctx;
      const uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
      return Array.from(
        { length: uniformCount },
        (_, i) => gl.getActiveUniform(program, i)
      ).filter(Boolean).map((uniform, index) => ({ ...uniform, index }));
    }
    makeShader(inputUniforms, localMatrix) {
      return this.makeShaderWithChildren(inputUniforms, void 0, localMatrix);
    }
    makeShaderWithChildren(inputUniforms, input, localMatrix) {
      const uniforms = Array.from(normalizeArray(inputUniforms));
      const mappedUniforms = createUniformMap(
        this.ctx.gl,
        this.ctx.program,
        uniforms
      );
      const children = input ? input.map((c) => c.getShader()) : [];
      return new ShaderJS(
        new WebGLShader(
          this.ctx,
          mappedUniforms,
          children,
          localMatrix ? nativeMatrix(localMatrix) : void 0
        )
      );
    }
    getUniform(index) {
      const uniform = this.uniformMap[index];
      if (!uniform) {
        throw new Error(`No uniform at index ${index}`);
      }
      const { gl } = this.ctx;
      let rows = 1, columns = 1, isInteger = false;
      switch (uniform.type) {
        case gl.FLOAT_VEC2:
          rows = 2;
          break;
        case gl.FLOAT_VEC3:
          rows = 3;
          break;
        case gl.FLOAT_VEC4:
          rows = 4;
          break;
        case gl.FLOAT_MAT2:
          rows = 2;
          columns = 2;
          break;
        case gl.FLOAT_MAT3:
          rows = 3;
          columns = 3;
          break;
        case gl.FLOAT_MAT4:
          rows = 4;
          columns = 4;
          break;
        case gl.INT:
          isInteger = true;
          break;
        case gl.INT_VEC2:
          isInteger = true;
          rows = 2;
          break;
        case gl.INT_VEC3:
          isInteger = true;
          rows = 3;
          break;
        case gl.INT_VEC4:
          isInteger = true;
          rows = 4;
          break;
        default:
          if (uniform.type !== gl.FLOAT) {
            throw new Error(`Unsupported uniform type: ${uniform.type}`);
          }
      }
      return { columns, rows, slot: uniform.index, isInteger };
    }
    getUniformCount() {
      return this.uniformMap.length;
    }
    getUniformFloatCount() {
      return this.uniformMap.filter((u) => u.type === this.ctx.gl.FLOAT).reduce((count, u) => count + u.size, 0);
    }
    getUniformName(index) {
      const uniform = this.uniformMap[index];
      if (!uniform) {
        throw new Error(`No uniform at index ${index}`);
      }
      return uniform.name;
    }
  };
  var getUniformNames = (gl, program) => {
    const uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    return Array.from(
      { length: uniformCount },
      (_, i) => gl.getActiveUniform(program, i).name
    ).filter(Boolean);
  };
  var createUniformMap = (gl, program, values) => {
    const uniformNames = getUniformNames(gl, program);
    let index = 0;
    return uniformNames.reduce((map, name, uniformIndex) => {
      if (name === "u_matrix" || name === "u_resolution") {
        return map;
      }
      const location = gl.getUniformLocation(program, name);
      if (!location) {
        console.error(`Uniform ${name} not found in shader program.`);
        return map;
      }
      const info = gl.getActiveUniform(program, uniformIndex);
      if (!info) {
        return map;
      }
      const size = getUniformSize(gl, info.type) * info.size;
      if (size === 0) {
        console.error(`Unsupported uniform type for ${name}.`);
        return map;
      }
      map[name] = values.slice(index, index + size);
      index += size;
      return map;
    }, {});
  };
  var getUniformSize = (gl, type) => {
    switch (type) {
      case gl.FLOAT:
      case gl.INT:
      case gl.SAMPLER_2D:
      case gl.SAMPLER_CUBE:
        return 1;
      case gl.FLOAT_VEC2:
      case gl.INT_VEC2:
        return 2;
      case gl.FLOAT_VEC3:
      case gl.INT_VEC3:
        return 3;
      case gl.FLOAT_VEC4:
      case gl.INT_VEC4:
      case gl.FLOAT_MAT2:
        return 4;
      case gl.FLOAT_MAT3:
        return 9;
      case gl.FLOAT_MAT4:
        return 16;
      default:
        return 0;
    }
  };

  // src/RuntimeEffect/RuntimeEffectFactory.ts
  var RuntimeEffectFactory = {
    Make(sksl, callback) {
      return new RuntimeEffectJS(new WebGLContext(sksl, false, callback));
    },
    MakeTraced(_shader, _traceCoordX, _traceCoordY) {
      throw new Error("Method not implemented.");
    }
  };

  // src/ColorFilter/ColorFilter.ts
  var ColorFilterJS = class extends NativeFilter {
    constructor() {
      super("ColorFilter");
    }
  };

  // src/ColorFilter/MatrixColorFilter.ts
  var MatrixColorFilter = class extends ColorFilterJS {
    constructor(values) {
      super();
      const cf = makeColorMatrix({ type: "matrix", values });
      this._filters.push(cf);
    }
  };

  // src/ColorFilter/ColorFilterFactory.ts
  var ColorFilterFactory = {
    MakeBlend: function(_color, _mode, _colorSpace) {
      throw new Error("Function not implemented.");
    },
    MakeCompose: function(_outer, _inner) {
      throw new Error("Function not implemented.");
    },
    MakeLerp: function(_t, _dst, _src) {
      throw new Error("Function not implemented.");
    },
    MakeLinearToSRGBGamma: function() {
      throw new Error("Function not implemented.");
    },
    MakeMatrix: function(cMatrix) {
      return new MatrixColorFilter(normalizeArray(cMatrix));
    },
    MakeSRGBToLinearGamma: function() {
      throw new Error("Function not implemented.");
    },
    MakeLuma: function() {
      throw new Error("Function not implemented.");
    }
  };

  // src/Path/ContourMeasure.ts
  var ContourMeasureJS = class extends HostObject {
    constructor(contour, _forceClosed, _resScale) {
      super("ContourMeasure");
      this.contour = contour;
    }
    getPosTan(distance, output = new Float32Array(4)) {
      const result = this.contour.getPosTanAtLength(distance);
      output[0] = result[0].x;
      output[1] = result[0].y;
      output[2] = result[1].x;
      output[3] = result[1].y;
      return output;
    }
    getSegment(startD, stopD, _startWithMoveTo = true) {
      const result = new PathJS();
      const contour = this.contour.getSegment(startD, stopD);
      result.getPath().contours.push(contour);
      return result;
    }
    isClosed() {
      return this.contour.closed;
    }
    length() {
      return this.contour.length();
    }
  };
  var ContourMeasureIterJS = class extends HostObject {
    constructor(path, forceClosed, resScale) {
      super("ContourMeasureIter");
      this.path = path;
      this.forceClosed = forceClosed;
      this.resScale = resScale;
    }
    index = 0;
    next() {
      const { path, forceClosed, resScale } = this;
      const contour = path.getPath().contours[this.index++];
      if (!contour) {
        return null;
      }
      return new ContourMeasureJS(contour, forceClosed, resScale);
    }
  };

  // src/Text/Parser/opentype/parse.ts
  function getUShort(buffer, offset) {
    return buffer.getUint16(offset);
  }
  function getTag(buffer, offset) {
    let tag = "";
    for (let i = offset; i < offset + 4; i++) {
      tag += String.fromCharCode(buffer.getInt8(i));
    }
    return tag;
  }
  function getULong(buffer, offset) {
    return buffer.getUint32(offset);
  }
  var typeOffsets = {
    byte: 1,
    fixed: 4,
    longDateTime: 8,
    short: 2,
    tag: 4,
    uLong: 4,
    uShort: 2
  };
  var Parser = class {
    offset;
    relativeOffset;
    data;
    constructor(data, offset) {
      this.data = data;
      this.offset = offset;
      this.relativeOffset = 0;
    }
    parseByte() {
      const v = this.data.getUint8(this.offset + this.relativeOffset);
      this.relativeOffset += 1;
      return v;
    }
    parseChar() {
      const v = this.data.getInt8(this.offset + this.relativeOffset);
      this.relativeOffset += 1;
      return v;
    }
    parseUShort() {
      const v = getUShort(this.data, this.offset + this.relativeOffset);
      this.relativeOffset += 2;
      return v;
    }
    parseShort() {
      const v = this.data.getInt16(this.offset + this.relativeOffset);
      this.relativeOffset += 2;
      return v;
    }
    parseULong() {
      const v = getULong(this.data, this.offset + this.relativeOffset);
      this.relativeOffset += 4;
      return v;
    }
    skip(type, amount) {
      if (amount === void 0) {
        amount = 1;
      }
      this.relativeOffset += (typeOffsets[type] || 0) * amount;
    }
  };

  // src/Text/Parser/opentype/cmap.ts
  function parseCmapTable(buf, start) {
    const cmap = {};
    cmap.version = getUShort(buf, start);
    cmap.numTables = getUShort(buf, start + 2);
    let offset = -1;
    for (let i = cmap.numTables - 1; i >= 0; i -= 1) {
      const platformId = getUShort(buf, start + 4 + i * 8);
      const encodingId = getUShort(buf, start + 4 + i * 8 + 2);
      if (platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10) || platformId === 0 && (encodingId === 0 || encodingId === 1 || encodingId === 2 || encodingId === 3 || encodingId === 4)) {
        offset = getULong(buf, start + 4 + i * 8 + 4);
        break;
      }
    }
    if (offset === -1) {
      throw new Error("No valid cmap sub-tables found.");
    }
    const parser = new Parser(buf, start + offset);
    cmap.format = parser.parseUShort();
    if (cmap.format === 12) {
      parseCmapTableFormat12(cmap, parser);
    } else if (cmap.format === 4) {
      parseCmapTableFormat4(cmap, parser, buf, start, offset);
    } else {
      throw new Error(
        "Only format 4 and 12 cmap tables are supported (found format " + cmap.format + ")."
      );
    }
    return cmap;
  }
  function parseCmapTableFormat12(cmap, p) {
    p.parseUShort();
    cmap.length = p.parseULong();
    cmap.language = p.parseULong();
    let groupCount;
    cmap.groupCount = groupCount = p.parseULong();
    cmap.glyphIndexMap = {};
    for (let i = 0; i < groupCount; i += 1) {
      const startCharCode = p.parseULong();
      const endCharCode = p.parseULong();
      let startGlyphId = p.parseULong();
      for (let c = startCharCode; c <= endCharCode; c += 1) {
        cmap.glyphIndexMap[c] = startGlyphId;
        startGlyphId++;
      }
    }
  }
  function parseCmapTableFormat4(cmap, p, data, start, offset) {
    cmap.length = p.parseUShort();
    cmap.language = p.parseUShort();
    let segCount;
    cmap.segCount = segCount = p.parseUShort() >> 1;
    p.skip("uShort", 3);
    cmap.glyphIndexMap = {};
    const endCountParser = new Parser(data, start + offset + 14);
    const startCountParser = new Parser(data, start + offset + 16 + segCount * 2);
    const idDeltaParser = new Parser(data, start + offset + 16 + segCount * 4);
    const idRangeOffsetParser = new Parser(
      data,
      start + offset + 16 + segCount * 6
    );
    let glyphIndexOffset = start + offset + 16 + segCount * 8;
    for (let i = 0; i < segCount - 1; i += 1) {
      let glyphIndex;
      const endCount = endCountParser.parseUShort();
      const startCount = startCountParser.parseUShort();
      const idDelta = idDeltaParser.parseShort();
      const idRangeOffset = idRangeOffsetParser.parseUShort();
      for (let c = startCount; c <= endCount; c += 1) {
        if (idRangeOffset !== 0) {
          glyphIndexOffset = idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2;
          glyphIndexOffset += idRangeOffset;
          glyphIndexOffset += (c - startCount) * 2;
          glyphIndex = getUShort(data, glyphIndexOffset);
          if (glyphIndex !== 0) {
            glyphIndex = glyphIndex + idDelta & 65535;
          }
        } else {
          glyphIndex = c + idDelta & 65535;
        }
        cmap.glyphIndexMap[c] = glyphIndex;
      }
    }
  }

  // src/Text/Parser/opentype/ltag.ts
  function parseLtagTable(data, start) {
    const p = new Parser(data, start);
    const tableVersion = p.parseULong();
    if (tableVersion !== 1) {
      throw Error("Unsupported ltag table version");
    }
    p.skip("uLong", 1);
    const numTags = p.parseULong();
    const tags = [];
    for (let i = 0; i < numTags; i++) {
      let tag = "";
      const offset = start + p.parseUShort();
      const length2 = p.parseUShort();
      for (let j = offset; j < offset + length2; ++j) {
        tag += String.fromCharCode(data.getInt8(j));
      }
      tags.push(tag);
    }
    return tags;
  }

  // src/Text/Parser/opentype/decode.ts
  var eightBitMacEncodings = {
    // Python: 'mac_croatian'
    "x-mac-croatian": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\u0160\u2122\xB4\xA8\u2260\u017D\xD8\u221E\xB1\u2264\u2265\u2206\xB5\u2202\u2211\u220F\u0161\u222B\xAA\xBA\u03A9\u017E\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u0106\xAB\u010C\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u0110\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\uF8FF\xA9\u2044\u20AC\u2039\u203A\xC6\xBB\u2013\xB7\u201A\u201E\u2030\xC2\u0107\xC1\u010D\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u0111\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u03C0\xCB\u02DA\xB8\xCA\xE6\u02C7",
    // Python: 'mac_cyrillic'
    "x-mac-cyrillic": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u2020\xB0\u0490\xA3\xA7\u2022\xB6\u0406\xAE\xA9\u2122\u0402\u0452\u2260\u0403\u0453\u221E\xB1\u2264\u2265\u0456\xB5\u0491\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040A\u045A\u0458\u0405\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\u040B\u045B\u040C\u045C\u0455\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u201E\u040E\u045E\u040F\u045F\u2116\u0401\u0451\u044F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E",
    // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT
    "x-mac-gaelic": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u1E02\xB1\u2264\u2265\u1E03\u010A\u010B\u1E0A\u1E0B\u1E1E\u1E1F\u0120\u0121\u1E40\xE6\xF8\u1E41\u1E56\u1E57\u027C\u0192\u017F\u1E60\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\u1E61\u1E9B\xFF\u0178\u1E6A\u20AC\u2039\u203A\u0176\u0177\u1E6B\xB7\u1EF2\u1EF3\u204A\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u2663\xD2\xDA\xDB\xD9\u0131\xDD\xFD\u0174\u0175\u1E84\u1E85\u1E80\u1E81\u1E82\u1E83",
    // Python: 'mac_greek'
    "x-mac-greek": "\xC4\xB9\xB2\xC9\xB3\xD6\xDC\u0385\xE0\xE2\xE4\u0384\xA8\xE7\xE9\xE8\xEA\xEB\xA3\u2122\xEE\xEF\u2022\xBD\u2030\xF4\xF6\xA6\u20AC\xF9\xFB\xFC\u2020\u0393\u0394\u0398\u039B\u039E\u03A0\xDF\xAE\xA9\u03A3\u03AA\xA7\u2260\xB0\xB7\u0391\xB1\u2264\u2265\xA5\u0392\u0395\u0396\u0397\u0399\u039A\u039C\u03A6\u03AB\u03A8\u03A9\u03AC\u039D\xAC\u039F\u03A1\u2248\u03A4\xAB\xBB\u2026\xA0\u03A5\u03A7\u0386\u0388\u0153\u2013\u2015\u201C\u201D\u2018\u2019\xF7\u0389\u038A\u038C\u038E\u03AD\u03AE\u03AF\u03CC\u038F\u03CD\u03B1\u03B2\u03C8\u03B4\u03B5\u03C6\u03B3\u03B7\u03B9\u03BE\u03BA\u03BB\u03BC\u03BD\u03BF\u03C0\u03CE\u03C1\u03C3\u03C4\u03B8\u03C9\u03C2\u03C7\u03C5\u03B6\u03CA\u03CB\u0390\u03B0\xAD",
    // Python: 'mac_iceland'
    "x-mac-icelandic": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\xDD\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\xD0\xF0\xDE\xFE\xFD\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7",
    // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT
    "x-mac-inuit": "\u1403\u1404\u1405\u1406\u140A\u140B\u1431\u1432\u1433\u1434\u1438\u1439\u1449\u144E\u144F\u1450\u1451\u1455\u1456\u1466\u146D\u146E\u146F\u1470\u1472\u1473\u1483\u148B\u148C\u148D\u148E\u1490\u1491\xB0\u14A1\u14A5\u14A6\u2022\xB6\u14A7\xAE\xA9\u2122\u14A8\u14AA\u14AB\u14BB\u14C2\u14C3\u14C4\u14C5\u14C7\u14C8\u14D0\u14EF\u14F0\u14F1\u14F2\u14F4\u14F5\u1505\u14D5\u14D6\u14D7\u14D8\u14DA\u14DB\u14EA\u1528\u1529\u152A\u152B\u152D\u2026\xA0\u152E\u153E\u1555\u1556\u1557\u2013\u2014\u201C\u201D\u2018\u2019\u1558\u1559\u155A\u155D\u1546\u1547\u1548\u1549\u154B\u154C\u1550\u157F\u1580\u1581\u1582\u1583\u1584\u1585\u158F\u1590\u1591\u1592\u1593\u1594\u1595\u1671\u1672\u1673\u1674\u1675\u1676\u1596\u15A0\u15A1\u15A2\u15A3\u15A4\u15A5\u15A6\u157C\u0141\u0142",
    // Python: 'mac_latin2'
    "x-mac-ce": "\xC4\u0100\u0101\xC9\u0104\xD6\xDC\xE1\u0105\u010C\xE4\u010D\u0106\u0107\xE9\u0179\u017A\u010E\xED\u010F\u0112\u0113\u0116\xF3\u0117\xF4\xF6\xF5\xFA\u011A\u011B\xFC\u2020\xB0\u0118\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\u0119\xA8\u2260\u0123\u012E\u012F\u012A\u2264\u2265\u012B\u0136\u2202\u2211\u0142\u013B\u013C\u013D\u013E\u0139\u013A\u0145\u0146\u0143\xAC\u221A\u0144\u0147\u2206\xAB\xBB\u2026\xA0\u0148\u0150\xD5\u0151\u014C\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\u014D\u0154\u0155\u0158\u2039\u203A\u0159\u0156\u0157\u0160\u201A\u201E\u0161\u015A\u015B\xC1\u0164\u0165\xCD\u017D\u017E\u016A\xD3\xD4\u016B\u016E\xDA\u016F\u0170\u0171\u0172\u0173\xDD\xFD\u0137\u017B\u0141\u017C\u0122\u02C7",
    // Python: 'mac_roman'
    macintosh: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\u2039\u203A\uFB01\uFB02\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7",
    // Python: 'mac_romanian'
    "x-mac-romanian": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\u0102\u0218\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\u0103\u0219\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\u2039\u203A\u021A\u021B\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7",
    // Python: 'mac_turkish'
    "x-mac-turkish": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u011E\u011F\u0130\u0131\u015E\u015F\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\uF8A0\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
  };
  function UTF16(data, offset, numBytes) {
    const codePoints = [];
    const numChars = numBytes / 2;
    for (let j = 0; j < numChars; j++, offset += 2) {
      codePoints[j] = data.getUint16(offset);
    }
    return String.fromCharCode.apply(null, codePoints);
  }
  function MACSTRING(dataView, offset, dataLength, encoding) {
    const table = eightBitMacEncodings[encoding];
    if (table === void 0) {
      return void 0;
    }
    let result = "";
    for (let i = 0; i < dataLength; i++) {
      const c = dataView.getUint8(offset + i);
      if (c <= 127) {
        result += String.fromCharCode(c);
      } else {
        result += table[c & 127];
      }
    }
    return result;
  }
  var decode = {
    MACSTRING,
    UTF16
  };

  // src/Text/Parser/opentype/name.ts
  var nameTableNames = [
    "copyright",
    // 0
    "fontFamily",
    // 1
    "fontSubfamily",
    // 2
    "uniqueID",
    // 3
    "fullName",
    // 4
    "version",
    // 5
    "postScriptName",
    // 6
    "trademark",
    // 7
    "manufacturer",
    // 8
    "designer",
    // 9
    "description",
    // 10
    "manufacturerURL",
    // 11
    "designerURL",
    // 12
    "license",
    // 13
    "licenseURL",
    // 14
    "reserved",
    // 15
    "preferredFamily",
    // 16
    "preferredSubfamily",
    // 17
    "compatibleFullName",
    // 18
    "sampleText",
    // 19
    "postScriptFindFontName",
    // 20
    "wwsFamily",
    // 21
    "wwsSubfamily"
    // 22
  ];
  var macLanguages = {
    0: "en",
    1: "fr",
    2: "de",
    3: "it",
    4: "nl",
    5: "sv",
    6: "es",
    7: "da",
    8: "pt",
    9: "no",
    10: "he",
    11: "ja",
    12: "ar",
    13: "fi",
    14: "el",
    15: "is",
    16: "mt",
    17: "tr",
    18: "hr",
    19: "zh-Hant",
    20: "ur",
    21: "hi",
    22: "th",
    23: "ko",
    24: "lt",
    25: "pl",
    26: "hu",
    27: "es",
    28: "lv",
    29: "se",
    30: "fo",
    31: "fa",
    32: "ru",
    33: "zh",
    34: "nl-BE",
    35: "ga",
    36: "sq",
    37: "ro",
    38: "cz",
    39: "sk",
    40: "si",
    41: "yi",
    42: "sr",
    43: "mk",
    44: "bg",
    45: "uk",
    46: "be",
    47: "uz",
    48: "kk",
    49: "az-Cyrl",
    50: "az-Arab",
    51: "hy",
    52: "ka",
    53: "mo",
    54: "ky",
    55: "tg",
    56: "tk",
    57: "mn-CN",
    58: "mn",
    59: "ps",
    60: "ks",
    61: "ku",
    62: "sd",
    63: "bo",
    64: "ne",
    65: "sa",
    66: "mr",
    67: "bn",
    68: "as",
    69: "gu",
    70: "pa",
    71: "or",
    72: "ml",
    73: "kn",
    74: "ta",
    75: "te",
    76: "si",
    77: "my",
    78: "km",
    79: "lo",
    80: "vi",
    81: "id",
    82: "tl",
    83: "ms",
    84: "ms-Arab",
    85: "am",
    86: "ti",
    87: "om",
    88: "so",
    89: "sw",
    90: "rw",
    91: "rn",
    92: "ny",
    93: "mg",
    94: "eo",
    128: "cy",
    129: "eu",
    130: "ca",
    131: "la",
    132: "qu",
    133: "gn",
    134: "ay",
    135: "tt",
    136: "ug",
    137: "dz",
    138: "jv",
    139: "su",
    140: "gl",
    141: "af",
    142: "br",
    143: "iu",
    144: "gd",
    145: "gv",
    146: "ga",
    147: "to",
    148: "el-polyton",
    149: "kl",
    150: "az",
    151: "nn"
  };
  var windowsLanguages = {
    1078: "af",
    1052: "sq",
    1156: "gsw",
    1118: "am",
    5121: "ar-DZ",
    15361: "ar-BH",
    3073: "ar",
    2049: "ar-IQ",
    11265: "ar-JO",
    13313: "ar-KW",
    12289: "ar-LB",
    4097: "ar-LY",
    6145: "ary",
    8193: "ar-OM",
    16385: "ar-QA",
    1025: "ar-SA",
    10241: "ar-SY",
    7169: "aeb",
    14337: "ar-AE",
    9217: "ar-YE",
    1067: "hy",
    1101: "as",
    2092: "az-Cyrl",
    1068: "az",
    1133: "ba",
    1069: "eu",
    1059: "be",
    2117: "bn",
    1093: "bn-IN",
    8218: "bs-Cyrl",
    5146: "bs",
    1150: "br",
    1026: "bg",
    1027: "ca",
    3076: "zh-HK",
    5124: "zh-MO",
    2052: "zh",
    4100: "zh-SG",
    1028: "zh-TW",
    1155: "co",
    1050: "hr",
    4122: "hr-BA",
    1029: "cs",
    1030: "da",
    1164: "prs",
    1125: "dv",
    2067: "nl-BE",
    1043: "nl",
    3081: "en-AU",
    10249: "en-BZ",
    4105: "en-CA",
    9225: "en-029",
    16393: "en-IN",
    6153: "en-IE",
    8201: "en-JM",
    17417: "en-MY",
    5129: "en-NZ",
    13321: "en-PH",
    18441: "en-SG",
    7177: "en-ZA",
    11273: "en-TT",
    2057: "en-GB",
    1033: "en",
    12297: "en-ZW",
    1061: "et",
    1080: "fo",
    1124: "fil",
    1035: "fi",
    2060: "fr-BE",
    3084: "fr-CA",
    1036: "fr",
    5132: "fr-LU",
    6156: "fr-MC",
    4108: "fr-CH",
    1122: "fy",
    1110: "gl",
    1079: "ka",
    3079: "de-AT",
    1031: "de",
    5127: "de-LI",
    4103: "de-LU",
    2055: "de-CH",
    1032: "el",
    1135: "kl",
    1095: "gu",
    1128: "ha",
    1037: "he",
    1081: "hi",
    1038: "hu",
    1039: "is",
    1136: "ig",
    1057: "id",
    1117: "iu",
    2141: "iu-Latn",
    2108: "ga",
    1076: "xh",
    1077: "zu",
    1040: "it",
    2064: "it-CH",
    1041: "ja",
    1099: "kn",
    1087: "kk",
    1107: "km",
    1158: "quc",
    1159: "rw",
    1089: "sw",
    1111: "kok",
    1042: "ko",
    1088: "ky",
    1108: "lo",
    1062: "lv",
    1063: "lt",
    2094: "dsb",
    1134: "lb",
    1071: "mk",
    2110: "ms-BN",
    1086: "ms",
    1100: "ml",
    1082: "mt",
    1153: "mi",
    1146: "arn",
    1102: "mr",
    1148: "moh",
    1104: "mn",
    2128: "mn-CN",
    1121: "ne",
    1044: "nb",
    2068: "nn",
    1154: "oc",
    1096: "or",
    1123: "ps",
    1045: "pl",
    1046: "pt",
    2070: "pt-PT",
    1094: "pa",
    1131: "qu-BO",
    2155: "qu-EC",
    3179: "qu",
    1048: "ro",
    1047: "rm",
    1049: "ru",
    9275: "smn",
    4155: "smj-NO",
    5179: "smj",
    3131: "se-FI",
    1083: "se",
    2107: "se-SE",
    8251: "sms",
    6203: "sma-NO",
    7227: "sms",
    1103: "sa",
    7194: "sr-Cyrl-BA",
    3098: "sr",
    6170: "sr-Latn-BA",
    2074: "sr-Latn",
    1132: "nso",
    1074: "tn",
    1115: "si",
    1051: "sk",
    1060: "sl",
    11274: "es-AR",
    16394: "es-BO",
    13322: "es-CL",
    9226: "es-CO",
    5130: "es-CR",
    7178: "es-DO",
    12298: "es-EC",
    17418: "es-SV",
    4106: "es-GT",
    18442: "es-HN",
    2058: "es-MX",
    19466: "es-NI",
    6154: "es-PA",
    15370: "es-PY",
    10250: "es-PE",
    20490: "es-PR",
    // Microsoft has defined two different language codes for
    // Spanish with modern sorting and Spanish with traditional
    // sorting. This makes sense for collation APIs, and it would be
    // possible to express this in BCP 47 language tags via Unicode
    // extensions (eg., es-u-co-trad is Spanish with traditional
    // sorting). However, for storing names in fonts, the distinction
    // does not make sense, so we give es in both cases.
    3082: "es",
    1034: "es",
    21514: "es-US",
    14346: "es-UY",
    8202: "es-VE",
    2077: "sv-FI",
    1053: "sv",
    1114: "syr",
    1064: "tg",
    2143: "tzm",
    1097: "ta",
    1092: "tt",
    1098: "te",
    1054: "th",
    1105: "bo",
    1055: "tr",
    1090: "tk",
    1152: "ug",
    1058: "uk",
    1070: "hsb",
    1056: "ur",
    2115: "uz-Cyrl",
    1091: "uz",
    1066: "vi",
    1106: "cy",
    1160: "wo",
    1157: "sah",
    1144: "ii",
    1130: "yo"
  };
  var macLanguageEncodings = {
    15: "x-mac-icelandic",
    // langIcelandic
    17: "x-mac-turkish",
    // langTurkish
    18: "x-mac-croatian",
    // langCroatian
    24: "x-mac-ce",
    // langLithuanian
    25: "x-mac-ce",
    // langPolish
    26: "x-mac-ce",
    // langHungarian
    27: "x-mac-ce",
    // langEstonian
    28: "x-mac-ce",
    // langLatvian
    30: "x-mac-icelandic",
    // langFaroese
    37: "x-mac-romanian",
    // langRomanian
    38: "x-mac-ce",
    // langCzech
    39: "x-mac-ce",
    // langSlovak
    40: "x-mac-ce",
    // langSlovenian
    143: "x-mac-inuit",
    // langInuktitut
    146: "x-mac-gaelic"
    // langIrishGaelicScript
  };
  var macScriptEncodings = {
    0: "macintosh",
    // smRoman
    1: "x-mac-japanese",
    // smJapanese
    2: "x-mac-chinesetrad",
    // smTradChinese
    3: "x-mac-korean",
    // smKorean
    6: "x-mac-greek",
    // smGreek
    7: "x-mac-cyrillic",
    // smCyrillic
    9: "x-mac-devanagai",
    // smDevanagari
    10: "x-mac-gurmukhi",
    // smGurmukhi
    11: "x-mac-gujarati",
    // smGujarati
    12: "x-mac-oriya",
    // smOriya
    13: "x-mac-bengali",
    // smBengali
    14: "x-mac-tamil",
    // smTamil
    15: "x-mac-telugu",
    // smTelugu
    16: "x-mac-kannada",
    // smKannada
    17: "x-mac-malayalam",
    // smMalayalam
    18: "x-mac-sinhalese",
    // smSinhalese
    19: "x-mac-burmese",
    // smBurmese
    20: "x-mac-khmer",
    // smKhmer
    21: "x-mac-thai",
    // smThai
    22: "x-mac-lao",
    // smLao
    23: "x-mac-georgian",
    // smGeorgian
    24: "x-mac-armenian",
    // smArmenian
    25: "x-mac-chinesesimp",
    // smSimpChinese
    26: "x-mac-tibetan",
    // smTibetan
    27: "x-mac-mongolian",
    // smMongolian
    28: "x-mac-ethiopic",
    // smEthiopic
    29: "x-mac-ce",
    // smCentralEuroRoman
    30: "x-mac-vietnamese",
    // smVietnamese
    31: "x-mac-extarabic"
    // smExtArabic
  };
  var utf16 = "utf-16";
  function getLanguageCode(platformID, languageID, ltag) {
    switch (platformID) {
      case 0:
        if (languageID === 65535) {
          return "und";
        } else if (ltag) {
          return ltag[languageID];
        }
        break;
      case 1:
        return macLanguages[languageID];
      case 3:
        return windowsLanguages[languageID];
    }
    return void 0;
  }
  function getEncoding(platformID, encodingID, languageID) {
    switch (platformID) {
      case 0:
        return utf16;
      case 1:
        return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];
      case 3:
        if (encodingID === 1 || encodingID === 10) {
          return utf16;
        }
        break;
    }
    return void 0;
  }
  function parseNameTable(data, start, ltag) {
    const name = {};
    const p = new Parser(data, start);
    const format = p.parseUShort();
    const count = p.parseUShort();
    const stringOffset = p.offset + p.parseUShort();
    for (let i = 0; i < count; i++) {
      const platformID = p.parseUShort();
      const encodingID = p.parseUShort();
      const languageID = p.parseUShort();
      const nameID = p.parseUShort();
      const property = nameTableNames[nameID] || nameID;
      const byteLength = p.parseUShort();
      const offset = p.parseUShort();
      const language = getLanguageCode(platformID, languageID, ltag);
      const encoding = getEncoding(platformID, encodingID, languageID);
      if (encoding !== void 0 && language !== void 0) {
        let text;
        if (encoding === utf16) {
          text = decode.UTF16(data, stringOffset + offset, byteLength);
        } else {
          text = decode.MACSTRING(
            data,
            stringOffset + offset,
            byteLength,
            encoding
          );
        }
        if (text) {
          let translations = name[property];
          if (translations === void 0) {
            translations = name[property] = {};
          }
          translations[language] = text;
        }
      }
    }
    if (format === 1) {
      p.parseUShort();
    }
    return name;
  }

  // src/Text/Parser/opentype/index.ts
  function parseOpenTypeTableEntry(buf, numTables) {
    let p = 12;
    const tableEntries = {};
    for (let i = 0; i < numTables; i++) {
      const tag = getTag(buf, p);
      const entry = {
        checkSum: getULong(buf, p + 4),
        compression: false,
        length: getULong(buf, p + 12),
        offset: getULong(buf, p + 8)
      };
      if (tag === "cmap") {
        tableEntries.cmap = entry;
      } else if (tag === "name") {
        tableEntries.name = entry;
      } else if (tag === "ltag") {
        tableEntries.ltag = entry;
      }
      p += 16;
    }
    return tableEntries;
  }
  function parseWOFFTableEntry(buf, numTables) {
    let p = 44;
    const tableEntries = {};
    for (let i = 0; i < numTables; i += 1) {
      const tag = getTag(buf, p);
      const offset = getULong(buf, p + 4);
      const compLength = getULong(buf, p + 8);
      const origLength = getULong(buf, p + 12);
      let compression;
      if (compLength < origLength) {
        compression = "WOFF";
      } else {
        compression = false;
      }
      const entry = {
        compressedLength: compLength,
        compression,
        length: origLength,
        offset
      };
      if (tag === "cmap") {
        tableEntries.cmap = entry;
      } else if (tag === "name") {
        tableEntries.name = entry;
      } else if (tag === "ltag") {
        tableEntries.ltag = entry;
      }
      p += 20;
    }
    return tableEntries;
  }
  function uncompressTable(buf, cmapEntry) {
    if (cmapEntry.compression === "WOFF") {
      throw new Error("WOFF compression not supported");
    } else {
      return { buffer: buf, offset: cmapEntry.offset };
    }
  }
  function parseFontTable(input) {
    const buf = new DataView(input);
    const signature = getTag(buf, 0);
    let numTables;
    let tables;
    if (signature === String.fromCharCode(0, 1, 0, 0) || signature === "true" || signature === "typ1") {
      numTables = getUShort(buf, 4);
      tables = parseOpenTypeTableEntry(buf, numTables);
    } else if (signature === "OTTO") {
      numTables = getUShort(buf, 4);
      tables = parseOpenTypeTableEntry(buf, numTables);
    } else if (signature === "wOFF") {
      numTables = getUShort(buf, 12);
      tables = parseWOFFTableEntry(buf, numTables);
    } else {
      throw new Error("Unsupported OpenType signature" + signature);
    }
    if (tables.cmap == null || tables.name == null) {
      throw new Error("Unsupported Font");
    }
    const cmapTableUn = uncompressTable(buf, tables.cmap);
    const cmapTable = parseCmapTable(cmapTableUn.buffer, cmapTableUn.offset);
    let ltagTable = null;
    if (tables.ltag) {
      const ltagTableUn = uncompressTable(buf, tables.ltag);
      ltagTable = parseLtagTable(ltagTableUn.buffer, ltagTableUn.offset);
    }
    const namesTableUn = uncompressTable(buf, tables.name);
    const namesTable = parseNameTable(
      namesTableUn.buffer,
      namesTableUn.offset,
      ltagTable
    );
    return {
      cmap: cmapTable,
      namesTable
    };
  }

  // src/Text/Typeface.ts
  var TypefaceJS = class extends HostObject {
    constructor(familyName, data) {
      super("Typeface");
      this.familyName = familyName;
      if (data) {
        this.cmap = parseFontTable(data).cmap;
      }
    }
    cmap = null;
    // TODO: refactor so we don't need to create a typed array here
    getStringForGlyph(glyphID) {
      return this.glyphToText(Uint16Array.of(glyphID));
    }
    glyphToText(glyphs) {
      let text = "";
      const keys = Object.keys(this.cmap.glyphIndexMap);
      const values = Object.values(this.cmap.glyphIndexMap);
      for (let i = 0; i < glyphs.length; i++) {
        const index = values.indexOf(glyphs[i]);
        if (index !== -1) {
          text += String.fromCodePoint(Number(keys[index]));
        }
      }
      return text;
    }
    getGlyphIDs(str, numCodePoints, output) {
      const result = output ?? new Uint16Array(numCodePoints ?? str.length);
      for (let i = 0; i < result.length; i++) {
        const codepoint = str.codePointAt(i);
        const index = this.cmap?.glyphIndexMap[codepoint] ?? 0;
        result[i] = index;
      }
      return result;
    }
  };

  // src/Text/FontMgr.ts
  var FontMgrJS = class extends HostObject {
    constructor(typefaces) {
      super("FontMgr");
      this.typefaces = typefaces;
    }
    countFamilies() {
      return this.typefaces.length;
    }
    getFamilyName(index) {
      return this.typefaces[index].familyName;
    }
  };

  // src/Text/TypefaceFont.ts
  var loadFont = (data, familynameAlias) => {
    const familyName = familynameAlias ?? parseFontTable(data).namesTable.postScriptName.en;
    const font = new FontFace(familyName, data);
    font.load();
    document.fonts.add(font);
    return { familyName };
  };
  var TypefaceFontProviderJS = class extends FontMgrJS {
    constructor() {
      super([]);
    }
    registerFont(bytes, family) {
      loadFont(bytes, family);
    }
  };

  // src/Text/TypefaceFactory.ts
  var TypefaceFactory = {
    MakeFreeTypeFaceFromData(fontData) {
      const { familyName } = loadFont(fontData);
      return new TypefaceJS(familyName, fontData);
    }
  };

  // src/Text/TypefaceFontProviderFactory.ts
  var TypefaceFontProviderFactory = {
    Make: () => {
      return new TypefaceFontProviderJS();
    }
  };

  // src/Text/FontCollection.ts
  var FontCollectionJS = class extends HostObject {
    fontManager = null;
    constructor() {
      super("FontCollection");
    }
    enableFontFallback() {
    }
    setDefaultFontManager(fontManager) {
      this.fontManager = fontManager;
    }
  };

  // src/Text/FontCollectionFactory.ts
  var FontCollectionFactory = {
    Make: () => {
      return new FontCollectionJS();
    }
  };

  // src/Text/FontMgrFactory.ts
  var FontMgrFactory = {
    FromData(...buffers) {
      const typefaces = [];
      buffers.forEach((buffer) => {
        const typeface = TypefaceFactory.MakeFreeTypeFaceFromData(buffer);
        if (!typeface) {
          throw new Error("Could not load font");
        }
        typefaces.push(typeface);
      });
      return new FontMgrJS(typefaces);
    }
  };

  // src/Text/NativeText.ts
  var offscreen = new OffscreenCanvas(1, 1);
  var TextContext = offscreen.getContext("2d");
  var glyphArray = (input) => {
    return normalizeArray(input, Uint16Array);
  };

  // src/Text/Font.ts
  var FontJS = class extends HostObject {
    constructor(typeface, fontSize = 14, _scaleX, _skewX) {
      super("Font");
      this.fontSize = fontSize;
      this.typeface = typeface ?? new TypefaceJS("sans-serif", null);
    }
    typeface;
    fontStyle() {
      return `${this.fontSize}px ${this.typeface.familyName}`;
    }
    getMetrics() {
      TextContext.font = this.fontStyle();
      const ascent = TextContext.measureText("H").actualBoundingBoxAscent;
      const descent = TextContext.measureText("p").actualBoundingBoxDescent;
      const lineHeight = this.fontSize * 1.2;
      const leading = lineHeight - this.fontSize;
      return {
        ascent: -ascent,
        descent,
        leading
      };
    }
    getGlyphBounds(inputGlyphs, _paint, output) {
      const glyphs = glyphArray(inputGlyphs);
      const result = output ?? new Float32Array(glyphs.length * 4);
      const text = this.typeface.glyphToText(glyphs);
      for (let i = 0; i < text.length; i++) {
        TextContext.font = this.fontStyle();
        const metrics = TextContext.measureText(text[i]);
        result[i * 4 + 0] = -metrics.actualBoundingBoxLeft;
        result[i * 4 + 1] = -metrics.actualBoundingBoxAscent;
        result[i * 4 + 2] = metrics.actualBoundingBoxRight;
        result[i * 4 + 3] = metrics.actualBoundingBoxDescent;
      }
      return result;
    }
    getStringForGlyph(glyphID) {
      return this.typeface.getStringForGlyph(glyphID);
    }
    getGlyphIDs(str, numCodePoints, output) {
      return this.typeface.getGlyphIDs(str, numCodePoints, output);
    }
    getGlyphWidths(inputGlyphs, paint, output) {
      return this.getGlyphBounds(inputGlyphs, paint, output);
    }
    getGlyphIntercepts(_glyphs, _positions, _top, _bottom) {
      throw new Error("Method not implemented.");
    }
    getScaleX() {
      throw new Error("Method not implemented.");
    }
    getSize() {
      return this.fontSize;
    }
    getSkewX() {
      throw new Error("Method not implemented.");
    }
    isEmbolden() {
      throw new Error("Method not implemented.");
    }
    getTypeface() {
      throw new Error("Method not implemented.");
    }
    setEdging(_edging) {
      throw new Error("Method not implemented.");
    }
    setEmbeddedBitmaps(_embeddedBitmaps) {
      throw new Error("Method not implemented.");
    }
    setHinting(_hinting) {
      throw new Error("Method not implemented.");
    }
    setLinearMetrics(_linearMetrics) {
      throw new Error("Method not implemented.");
    }
    setScaleX(_sx) {
      throw new Error("Method not implemented.");
    }
    setSize(points) {
      this.fontSize = points;
    }
    setSkewX(_sx) {
      throw new Error("Method not implemented.");
    }
    setEmbolden(_embolden) {
      throw new Error("Method not implemented.");
    }
    setSubpixel(_subpixel) {
      throw new Error("Method not implemented.");
    }
    setTypeface(_face) {
      throw new Error("Method not implemented.");
    }
  };

  // src/Text/ParagraphStyle.ts
  function TextStyle(style) {
    return style;
  }
  var ParagraphStyle = (style) => {
    return style;
  };

  // src/Text/ParagraphBuilderFactory.ts
  var ParagraphBuilderFactory = {
    Make: function(_style, _fontManager) {
      throw new Error("Function not implemented.");
    },
    MakeFromFontProvider: function(_style, _fontSrc) {
      throw new Error("Function not implemented.");
    },
    MakeFromFontCollection: function(_style, _fontCollection) {
      throw new Error("Function not implemented.");
    },
    ShapeText: function(_text, _runs, _width) {
      throw new Error("Function not implemented.");
    },
    RequiresClientICU: function() {
      return true;
    }
  };

  // src/Picture/Picture.ts
  var PictureJS = class extends HostObject {
    constructor(canvas) {
      super("Picture");
      this.canvas = canvas;
    }
    makeShader(_tmx, _tmy, _mode, _localMatrix, _tileRect) {
      throw new Error("Method not implemented.");
    }
    serialize() {
      throw new Error("Method not implemented.");
    }
  };

  // src/Picture/PictureRecorder.ts
  var PictureRecorderJS = class extends IndexedHostObject {
    canvas = null;
    beginRecording(bounds) {
      this.canvas = new CanvasRecorder(normalizeArray(bounds));
      return this.canvas;
    }
    finishRecordingAsPicture() {
      if (!this.canvas) {
        throw new Error(
          "CanvasRecorder not initialized. Call beginRecording first."
        );
      }
      return new PictureJS(this.canvas);
    }
  };

  // src/TextBlob/TextBlobFactory.ts
  var TextBlobFactory = {
    MakeFromGlyphs: function(_glyphs, _font) {
      throw new Error("Function not implemented.");
    },
    MakeFromRSXform: function(_str, _rsxforms, _font) {
      throw new Error("Function not implemented.");
    },
    MakeFromRSXformGlyphs: function(_glyphs, _rsxforms, _font) {
      throw new Error("Function not implemented.");
    },
    MakeFromText: function(_str, _font) {
      throw new Error("Function not implemented.");
    },
    MakeOnPath: function(_str, _path, _font, _initialOffset) {
      throw new Error("Function not implemented.");
    }
  };

  // src/PathEffect/PathEffectFactory.ts
  var PathEffectFactory = {
    MakeCorner: function(_radius) {
      throw new Error("Function not implemented.");
    },
    MakeDash: function(_intervals, _phase) {
      throw new Error("Function not implemented.");
    },
    MakeDiscrete: function(_segLength, _dev, _seedAssist) {
      throw new Error("Function not implemented.");
    },
    MakeLine2D: function(_width, _matrix) {
      throw new Error("Function not implemented.");
    },
    MakePath1D: function(_path, _advance, _phase, _style) {
      throw new Error("Function not implemented.");
    },
    MakePath2D: function(_matrix, _path) {
      throw new Error("Function not implemented.");
    }
  };

  // src/ColorFilter/ColorMatrixHelpers.ts
  var ColorMatrixHelpers = {
    concat: function(_outer, _inner) {
      throw new Error("Function not implemented.");
    },
    identity: function() {
      throw new Error("Function not implemented.");
    },
    postTranslate: function(_m, _dr, _dg, _db, _da) {
      throw new Error("Function not implemented.");
    },
    rotated: function(_axis, _sine, _cosine) {
      throw new Error("Function not implemented.");
    },
    scaled: function(_redScale, _greenScale, _blueScale, _alphaScale) {
      throw new Error("Function not implemented.");
    }
  };

  // src/CanvasKit.ts
  var ctxId = 1;
  var CanvasKitJS = class _CanvasKitJS extends CoreCanvasKit {
    static instance = null;
    contextes = {};
    _colorCtx = null;
    constructor() {
      super();
    }
    get colorCtx() {
      if (this._colorCtx === null) {
        this._colorCtx = createOffscreenTexture(1, 1, {
          willReadFrequently: true
        });
      }
      return this._colorCtx;
    }
    static getInstance() {
      if (this.instance === null) {
        this.instance = new _CanvasKitJS();
      }
      return this.instance;
    }
    parseColorString(colorStr, _colorMap) {
      this.colorCtx.fillStyle = colorStr;
      this.colorCtx.fillRect(0, 0, 1, 1);
      const [r, g, b, a] = this.colorCtx.getImageData(0, 0, 1, 1).data;
      return Float32Array.of(r / 255, g / 255, b / 255, a / 255);
    }
    computeTonalColors(colors) {
      const ambient = normalizeArray(colors.ambient);
      const spot = normalizeArray(colors.spot);
      return {
        ambient,
        spot
      };
    }
    getShadowLocalBounds(_ctm, _path, _zPlaneParams, _lightPos, _lightRadius, _flags, _dstRect) {
      throw new Error("Method not implemented.");
    }
    Malloc(TypedArray, len) {
      return new MallocObjJS(new TypedArray(len));
    }
    MallocGlyphIDs(len) {
      return new MallocObjJS(new Uint16Array(len));
    }
    Free(_m) {
    }
    MakeCanvasSurface(canvas) {
      const ctx = resolveContext(canvas);
      if (!ctx) {
        return null;
      }
      return new SurfaceJS(ctx);
    }
    MakeRasterDirectSurface(_ii, _pixels, _bytesPerRow) {
      throw new Error("Method not implemented.");
    }
    MakeSWCanvasSurface(canvas) {
      return this.MakeCanvasSurface(canvas);
    }
    MakeWebGLCanvasSurface(canvas, colorSpace, _opts) {
      const ctx = resolveContext(canvas, {
        colorSpace: colorSpace?.getNativeValue()
      });
      if (!ctx) {
        return null;
      }
      return new SurfaceJS(ctx);
    }
    MakeSurface(width, height) {
      const ctx = createTexture(width, height);
      return new SurfaceJS(ctx);
    }
    GetWebGLContext(canvas, _opts) {
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        throw new Error("Unable to get 2d context from canvas");
      }
      const id = ctxId++;
      this.contextes[id] = ctx;
      return id;
    }
    MakeGrContext(ctx) {
      return new GrDirectContextJS(this.contextes[ctx]);
    }
    MakeWebGLContext(ctx) {
      return new GrDirectContextJS(this.contextes[ctx]);
    }
    MakeOnScreenGLSurface(_ctx, _width, _height, _colorSpace, _sampleCount, _stencil) {
      throw new Error("Method not implemented.");
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    MakeGPUDeviceContext(_device) {
      throw new Error("Method not implemented.");
    }
    MakeGPUTextureSurface(_ctx, _texture, _width, _height, _colorSpace) {
      throw new Error("Method not implemented.");
    }
    MakeGPUCanvasContext(_ctx, _canvas, _opts) {
      throw new Error("Method not implemented.");
    }
    MakeGPUCanvasSurface(_canvasContext, _colorSpace, _width, _height) {
      throw new Error("Method not implemented.");
    }
    MakeRenderTarget(grCtx, ...args) {
      if (typeof args[0] === "number" && typeof args[1] === "number") {
        grCtx.ctx.canvas.width = args[0];
        grCtx.ctx.canvas.height = args[1];
      } else if (typeof args[0] === "object") {
        grCtx.ctx.canvas.width = args[0].width;
        grCtx.ctx.canvas.height = args[0].height;
      }
      return new SurfaceJS(grCtx.ctx);
    }
    MakeLazyImageFromTextureSource(_src, _info, _srcIsPremul) {
      throw new Error("Method not implemented.");
    }
    deleteContext(ctx) {
      delete this.contextes[ctx];
    }
    getDecodeCacheLimitBytes() {
      throw new Error("Method not implemented.");
    }
    getDecodeCacheUsedBytes() {
      throw new Error("Method not implemented.");
    }
    setDecodeCacheLimitBytes(_size) {
      throw new Error("Method not implemented.");
    }
    MakeAnimatedImageFromEncoded(_bytes) {
      throw new Error("Method not implemented.");
    }
    MakeCanvas(width, height) {
      const texture = createTexture(width, height);
      return new EmulatedCanvas2DJS(texture.canvas);
    }
    MakeImage({ width, height, colorSpace }, data, _bytesPerRow) {
      const imageData = new ImageData(
        data instanceof Uint8ClampedArray ? data : new Uint8ClampedArray(data),
        width,
        height,
        {
          colorSpace: colorSpace ? colorSpace.getNativeValue() : "srgb"
        }
      );
      return new ImageJS(imageData);
    }
    MakeImageFromEncoded(_bytes) {
      throw new Error(
        `MakeImageFromEncoded in CanvasKit is synchronous and not supported on Web.
      Use MakeImageFromEncodedAsync instead.
      `
      );
    }
    MakeImageFromCanvasImageSource(src) {
      return new ImageJS(src);
    }
    MakePicture(_bytes) {
      throw new Error("Method not implemented.");
    }
    MakeVertices(_mode, _positions, _textureCoordinates, _colors, _indices, _isVolatile) {
      throw new Error("Method not implemented.");
    }
    MakeAnimation(_json) {
      throw new Error("Skottie is not available");
    }
    MakeManagedAnimation(_json, _assets, _filterPrefix, _soundMap) {
      throw new Error("Skottie is not available");
    }
    ParagraphStyle = ParagraphStyle;
    ContourMeasureIter = ContourMeasureIterJS;
    Font = FontJS;
    Paint = PaintJS;
    Path = PathJS;
    PictureRecorder = PictureRecorderJS;
    TextStyle = TextStyle;
    ParagraphBuilder = ParagraphBuilderFactory;
    ColorFilter = ColorFilterFactory;
    FontCollection = FontCollectionFactory;
    FontMgr = FontMgrFactory;
    ImageFilter = ImageFilterFactory;
    MaskFilter = MaskFilterFactory;
    RuntimeEffect = RuntimeEffectFactory;
    Shader = ShaderFactory;
    Typeface = TypefaceFactory;
    TypefaceFontProvider = TypefaceFontProviderFactory;
    PathEffect = PathEffectFactory;
    ImageData = ImageData;
    ColorMatrix = ColorMatrixHelpers;
    TextBlob = TextBlobFactory;
    // The methods below are specific to canvaskit-js
    MakeImageFromURIAsync(url) {
      const img = new window.Image();
      img.src = url;
      return new Promise((resolve, reject) => {
        img.onload = () => {
          img.width = img.naturalWidth;
          img.height = img.naturalHeight;
          const result = new ImageJS(img);
          if (!result) {
            reject();
          }
          resolve(result);
        };
      });
    }
    MakeImageFromEncodedAsync(bytes, imageFormat) {
      let type = "image/png";
      if (imageFormat === 3 /* JPEG */) {
        type = "image/jpeg";
      } else if (imageFormat === 6 /* WEBP */) {
        type = "image/webp";
      }
      const blob = new Blob([bytes], { type });
      const url = URL.createObjectURL(blob);
      return this.MakeImageFromURIAsync(url);
    }
  };

  // src/index.ts
  var CanvasKitInit = () => new Promise((resolve) => resolve(CanvasKitJS.getInstance()));
  if (window) {
    window.CanvasKitJS = CanvasKitJS.getInstance();
    window.C2D = {
      Path,
      Paint,
      Canvas,
      BlurImageFilter,
      WebGLShader,
      WebGLContext,
      LinearGradient
    };
  }
  var src_default = CanvasKitInit;
})();
